// Generated by dts-bundle-generator v9.5.1

/**
 * @internal
 */
/**
 * Region configuration object interface (flat, mutually exclusive)
 * A region is either:
 * - API/SSE pair (no tdeploy), or
 * - TDeploy (no api/sse)
 */
export interface RegionsObjApi {
	/** API endpoint URL */
	api: string;
	/** Server-sent events endpoint URL */
	sse: string;
	/** Disallow tdeploy when api/sse present */
	tdeploy?: never;
}
export interface RegionsObjTDeploy {
	/** TagoIO Deploy Project ID */
	tdeploy: string;
	/** Disallow api/sse when tdeploy present */
	api?: never;
	sse?: never;
}
export type RegionsObj = RegionsObjApi | RegionsObjTDeploy;
/**
 * Supported TagoIO regions
 */
export type Regions = "us-e1" | "eu-w1" | "env";
/**
 * Object of Regions Definition
 * @internal
 */
export declare const regionsDefinition: Record<string, RegionsObjApi | undefined>;
/**
 * Set region in-memory to be inherited by other modules when set in the Analysis runtime
 * with `Analysis.use()`.
 *
 * @example
 *
 * ```ts
 * async function myAnalysis(context, scope) {
 *   // this uses the region defined through `use`
 *   const resources = new Resources({ token });
 *
 *   // it's still possible to override if needed
 *   const europeResources = new Resources({ token, region: "eu-w1" });
 * }
 *
 * Analysis.use(myAnalysis, { region: "us-e1" });
 * ```
 */
export declare function setRuntimeRegion(region: RegionsObj): void;
export interface GenericModuleParams {
	token?: string;
	region?: Regions | RegionsObj;
}
export interface ShareModuleParams extends GenericModuleParams {
	type: RefType;
}
export interface TokenModuleParams extends GenericModuleParams {
	path: string;
	id?: GenericID;
}
export interface ConnectorModuleParams extends GenericModuleParams {
	details?: boolean;
}
export interface AuthorizationModuleParams extends GenericModuleParams {
	details?: boolean;
}
/**
 * Object for generate request params
 * @internal
 */
export interface doRequestParams {
	path: string;
	method: string;
	body?: any;
	params?: any;
	headers?: any;
	overwriteRequestConfig?: RequestConfig;
	maxContentLength?: number;
	/**
	 * Cache for request
	 * default: false (disabled)
	 */
	cacheTTL?: number;
}
declare abstract class TagoIOModule<T extends GenericModuleParams> {
	protected params: T;
	constructor(params: T);
	private validateParams;
	protected doRequest<TR>(requestObj: doRequestParams): Promise<TR>;
	protected static doRequestAnonymous<TR>(requestObj: doRequestParams, region?: Regions | RegionsObj): Promise<TR>;
}
declare const channelsWithID: readonly [
	"analysis_console",
	"device_inspector",
	"device_data",
	"entity_data",
	"ui_dashboard"
];
declare const channelsWithoutID: readonly [
	"analysis_trigger",
	"notification",
	"ui"
];
export declare const channels: readonly string[];
export type ChannelWithID = (typeof channelsWithID)[number];
export type ChannelWithoutID = (typeof channelsWithoutID)[number];
export type OpenSSEWithID = {
	channel: ChannelWithID;
	resource_id: string;
};
export type OpenSSEWithoutID = {
	channel: ChannelWithoutID;
};
export type OpenSSEConfig = OpenSSEWithID | OpenSSEWithoutID;
export declare function openSSEListening(channels: OpenSSEConfig | OpenSSEConfig[], options: GenericModuleParams): Promise<EventSource>;
export type analysisFunction = (context: any, data: any) => any;
export interface AnalysisConstructorParams {
	token?: string;
	region?: Regions | RegionsObj;
	/**
	 * Auto Start analysis after instance the class
	 * If turn it off, you can start analysis calling [AnalysisInstance].start();
	 * [Default: true]
	 */
	autostart?: boolean;
	/**
	 * Load TagoIO Analysis envs on process.env.
	 *
	 * Warning: It's not safe to use on external analysis
	 * It will load all env on process, then if the external analysis receive multiples requests
	 * simultaneous, it can mass up.
	 *
	 * [Default: false]
	 */
	loadEnvOnProcess?: boolean;
}
export interface AnalysisEnvironment {
	[key: string]: string;
}
export type AnalysisToken = string;
export type AnalysisID = string;
/**
 * As current version of the SDK doesn't provide the TagoContext interface.
 */
export interface TagoContext {
	token: AnalysisToken;
	analysis_id: AnalysisID;
	environment: AnalysisEnvironment[];
	log: (...args: any[]) => void;
}
export interface AuthorizationInfo {
	name: string;
	type: string;
	permission: PermissionOption;
	serie_number: string | null;
	last_authorization: Date | null;
	verification_code: string;
	expire_time: ExpireTimeOption;
	ref_id: GenericID;
	created_at: Date;
	created_by: string | null;
}
export interface DeviceItem {
	id: GenericID;
	profile: string;
	bucket: {
		id: GenericID;
		name: string;
	};
	name: string;
	description: string | undefined;
	visible: boolean;
	active: boolean;
	last_output: Date | null;
	last_input: Date | null;
	connector: string;
	network: string;
	connector_parse: boolean;
	parse_function: string;
	tags: TagsObj[];
	updated_at: Date;
	created_at: Date;
	inspected_at: Date | null;
	bucket_name?: string;
	payload_decoder?: string;
}
/**
 * @param token token
 */
export interface DeviceConstructorParams {
	token: GenericToken$1;
	region?: Regions | RegionsObj;
}
export type DataToSend = DataCreate;
export type DataToEdit = DataEdit;
export type valuesTypes = string | number | boolean | undefined;
export interface DataQueryBase {
	/**
	 * Filter by variables
	 * It can ben a array of string or only one string
	 */
	variables?: string[] | string;
	/**
	 * Filter by origins
	 * It can ben a array of string or only one string
	 *
	 * @deprecated Filtering by origins will be removed along with the Legacy buckets.
	 */
	origins?: string[] | string;
	/**
	 * Filter by series
	 * It can ben a array of string or only one string
	 *
	 * @deprecated Deprecating this in favor of `groups`.
	 */
	series?: string[] | string;
	/**
	 * Filter by groups.
	 *
	 * It can ben a array of strings or only one string, each string being a `group`.
	 */
	groups?: string[] | string;
	/**
	 * Filter by ids
	 * It can ben a array of string or only one string
	 */
	ids?: string[] | string;
	/**
	 * Filter by values
	 * It can ben a array or only one element
	 */
	values?: valuesTypes[] | valuesTypes;
	/** Set the start date of query */
	start_date?: Date | string;
	/**
	 * Set the end date of query
	 * @default
	 * Date.now()
	 */
	end_date?: Date | string;
	/** Add internal details in each record */
	details?: boolean;
}
export type DataQueryDefault = DataQueryBase & {
	query?: "default";
	/** Qty of records to retrieve */
	qty?: number;
	/**
	 * Change ordination of query
	 * @default "descending"
	 */
	ordination?: "descending" | "ascending";
	/** Skip records, used on pagination or pooling */
	skip?: number;
};
export type DataQueryFirstLast = DataQueryBase & {
	query: "last_item" | "last_value" | "last_location" | "last_insert" | "first_item" | "first_value" | "first_location" | "first_insert" | "aggregate" | "conditional";
};
export type DataQueryAvgSum = Omit<DataQueryBase, "start_date"> & {
	query: "avg" | "sum";
	start_date: Date | string;
};
export type DataQuerySummary = DataQueryBase & {
	query: "min" | "max" | "count";
};
export type DataQueryAggregate = DataQueryBase & {
	query: "aggregate";
	interval: "minute" | "hour" | "day" | "month" | "quarter" | "year";
	function: "avg" | "sum" | "min" | "max";
};
export type DataQueryConditional = Omit<DataQueryBase, "start_date"> & {
	query: "conditional";
	start_date: Date | string;
	value: number;
	function: "gt" | "gte" | "lt" | "lte" | "eq" | "ne";
};
export type DataQuery = DataQueryDefault | DataQueryFirstLast | DataQuerySummary | DataQueryAvgSum | DataQueryAggregate | DataQueryConditional;
export type DataQueryStreaming = Omit<DataQueryDefault, "qty" | "skip" | "query" | "ordination">;
export interface OptionsStreaming {
	/**
	 * Qty of records by pooling
	 * @default 1000
	 */
	poolingRecordQty?: number;
	/**
	 * Time (milliseconds) between each request
	 * @default 1000 = (1 second)
	 */
	poolingTime?: number;
	/**
	 * Never Stop pooling data
	 * The streaming will not stop after get all data
	 * @default false
	 */
	neverStop?: boolean;
	/**
	 * start skip from a specific record
	 * @default 0
	 */
	initialSkip?: number;
}
export type ListResponse = DeviceItem[];
export type DataQueryNumberResponse = Pick<Data, "time"> & {
	value: number;
};
export interface IDictionaryModuleParams extends GenericModuleParams {
	token: string;
	region?: Regions | RegionsObj;
	language?: string;
	options?: object;
}
export interface IDictionaryModuleParamsAnonymous extends GenericModuleParams {
	runURL: string;
	region?: Regions | RegionsObj;
	language?: string;
	options?: object;
}
export interface IParsedExpression {
	dictionary: string;
	key: string;
	params?: string[];
}
export interface IResolveExpressionParams {
	language: string;
	expression: IParsedExpression;
}
export interface IApplyToStringOptions {
	language?: string;
}
export declare enum InputFormField {
	Text = "text",
	Address = "address",
	Barcode = "barcode",
	Calendar = "calendar",
	"Capture user" = "user",
	Checkbox = "checkbox",
	"Clock Set" = "clock-set",
	Device = "device",
	Dropdown = "dropdown",
	"Dropdown Multiple" = "dropdown-multi",
	Email = "email",
	"File Upload" = "upload",
	"Filtered variables" = "filtered",
	Hidden = "hidden",
	"Image / Video Select" = "image-select",
	"Incremental Step" = "incremental-step",
	Number = "number",
	Password = "password",
	"QR Code" = "qrcode",
	Radio = "radio",
	Validation = "validation"
}
export declare function convertSubmitButton(oldDisplay: any, runAnalysis: string): Record<string, any>;
export declare function convertFormField(field: any): any;
export declare function convertVisualField(field: any): any;
/**
 * Convert text fields to new widget format
 */
export declare function convertFieldText(field: any): any;
/**
 * Convert address fields to new widget format
 */
export declare function convertFieldAddress(field: any, showMap?: any): any;
/**
 * Convert barcode fields to new widget format
 */
export declare function convertFieldBarCode(field: any): any;
/**
 * Convert calendar fields to new widget format
 */
export declare function convertFieldCalendar(field: any): any;
/**
 * Convert calendar fields to new widget format
 */
export declare function convertFieldCheckbox(field: any): any;
/**
 * Convert clock set fields to new widget format
 */
export declare function convertFieldClockSet(field: any): any;
/**
 * Convert device fields to new widget format
 */
export declare function convertFieldDevice(field: any): any;
/**
 * Convert dropdown field to new widget format
 */
export declare function convertFieldDropdown(field: any): any;
/**
 * Convert dropdown multiples field to new widget format
 */
export declare function convertFieldDropdownMultiple(field: any): any;
/**
 * Convert email field to new widget format
 */
export declare function convertFieldEmail(field: any): any;
/**
 * Convert file upload field to new widget format
 */
export declare function convertFieldFileUpload(field: any): any;
/**
 * Convert filtered variables field to new widget format
 */
export declare function convertFieldFilteredVariables(field: any): any;
/**
 * Convert hidden field to new widget format
 */
export declare function convertFieldHidden(field: any): any;
/**
 * Convert Image / Video select field to new widget format
 */
export declare function convertFieldImageVideoSelect(field: any): any;
/**
 * Convert Incremental steps field for new widget format
 */
export declare function convertFieldIncrementalSteps(field: any): any;
/**
 * Convert Number field to new widget format
 */
export declare function convertFieldNumber(field: any): any;
/**
 * Convert Password field to new widget format
 */
export declare function convertFieldPassword(field: any): any;
/**
 * Convert QR Code field to new widget format
 */
export declare function convertFieldQrCode(field: any): any;
/**
 * Convert Radio field to new widget format
 */
export declare function convertFieldRadio(field: any): any;
/**
 * Convert Validation field to new widget format
 */
export declare function convertFieldValidation(field: any): any;
/**
 * Convert Capture user field to new widget format
 */
export declare function convertFieldCaptureUser(field: any): any;
/**
 * Convert fields
 */
export declare function convertField(field: any, showMap?: any): any;
export interface IDeviceParameters {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	options?: any[];
}
export interface INetworkInfo {
	id?: string;
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
	require_devices_access?: boolean;
}
export interface NetworkDeviceListQuery extends Omit<Query<DeviceItem, "name" | "visible" | "last_input" | "last_output" | "created_at" | "updated_at">, "fields"> {
}
export interface NetworkDeviceListQueryInfo extends DeviceItem {
	token: string;
}
interface Permissions$1 {
	effect: "allow" | "deny";
	action: string[];
	resource: string[];
}
export interface AccessCreateInfo {
	name: string;
	permissions: Permissions$1[];
	targets: [
	];
	profile?: GenericID;
	tags?: TagsObj[];
	active?: boolean;
}
export interface AccessInfo extends AccessCreateInfo {
	id: GenericID;
	created_at: Date;
	updated_at: Date;
}
export type AccessQuery = Query<AccessInfo, "name" | "active" | "created_at" | "updated_at">;
export type BillingPlan = "free" | "starter" | "scale";
export type BillingService = "input" | "output" | "analysis" | "data_records" | "sms" | "email" | "run_users" | "push_notification" | "file_storage";
export type BillingAddOn = "mobile" | "custom_dns";
export type BillingServiceSubscription = {
	limit: number;
};
export type BillingSubscriptionServices = Record<BillingService, BillingServiceSubscription>;
export type BillingSubscriptionAddOns = Record<BillingAddOn, GenericID[]>;
export type BillingPaymentError = {
	/** Payment error message. */
	message: string | null;
	/** More details on the payment error. */
	details: string | null;
};
export type BillingPaymentPastDue = {
	/** Amount due that was not paid in a recurring payment. */
	amount_due: number;
	/** Amount of attempts for the retried recurring payment. */
	attempt_count: number;
	/** URL for the invoice related to the failed recurring payment. */
	invoice_url: string;
};
export type BillingSubscription = {
	/** Account ID. */
	account: GenericID;
	/** Account plan. */
	plan: BillingPlan;
	/** Limits for each service in the account's subscription. */
	services: BillingSubscriptionServices;
	/** Add-ons in the account's subscription. */
	addons: BillingSubscriptionAddOns;
	/** Current cycle for the account's subscription. */
	current_cycle: {
		/** Date when the current cycle started. */
		start: string;
		/** Date when the current cycle ends. */
		end: string;
	};
	/** Whether changes are still being processed and awaiting response from Stripe. */
	processing: boolean;
	/** Payment errors in the account's subscription. */
	payment_error?: BillingPaymentError;
	/** Past due information for recurring payment errors. */
	past_due?: BillingPaymentPastDue;
	/** Value of the upcoming invoice. */
	upcoming_invoice_total: number;
	/** Timestamp when the trial for the subscription ends if the subscription has a trial active. */
	trial_end: string | null;
};
export type BillingEditSubscription = {
	/**
	 * New account plan.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	plan?: BillingPlan;
	/**
	 * New limits for each service in the account's subscription.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	services?: Partial<BillingSubscriptionServices>;
	/**
	 * New add-ons in the account's subscription.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	addons?: Partial<BillingSubscriptionAddOns>;
	/** Coupon code. */
	coupon?: string;
};
export type BillingServiceSubscriptionSchedule = Record<BillingService, BillingServiceSubscription & {
	/** Amount of proportional change the service's allocation will undergo. */
	proportional_change?: number | undefined;
}>;
export type BillingSubscriptionSchedule = {
	/** Account plan after the downgrade is applied. */
	plan?: BillingPlan;
	/** Limits for each service in the account's subscription after the downgrade is applied. */
	services?: BillingServiceSubscriptionSchedule;
	/** Add-ons in the account's subscription after the downgrade is applied. */
	addons?: Partial<BillingSubscriptionAddOns>;
};
export type BillingSchedule = {
	/** Account ID. */
	account: GenericID;
	/** When the schedule will be applied to the subscription. */
	release_at: string | null;
	/** Scheduled subscription changes. */
	subscription?: BillingSubscriptionSchedule;
};
export type BillingServicePrice = {
	/** Amount available in the service tier. */
	amount: number;
	/** Price for the service tier. */
	price: number;
};
export type BillingAllServicePrices = Record<BillingService, BillingServicePrice[]>;
export type BillingPlanPrices = Array<{
	/** Plan name. */
	name: BillingPlan;
	/** Plan price. */
	price: number;
}>;
export type BillingAddOnPrices = Array<{
	/** Add-on name. */
	name: BillingAddOn;
	/** Add-on price. */
	price: number;
}>;
export type BillingPrices = {
	/** Prices for each plan. */
	plans: BillingPlanPrices;
	/** Prices for each add-on. */
	addons: BillingAddOnPrices;
} & BillingAllServicePrices;
export type BillingPaymentMethodCard = {
	/** Name on the credit card. */
	name: string;
	/** Credit card brand. */
	brand: string;
	/** Credit card's last four digits. */
	last4: string;
	/** Credit card funding type. */
	funding: string;
	/** Credit card's expiration month. */
	exp_month: number;
	/** Credit card's expiration year. */
	exp_year: number;
};
export type BillingPaymentMethodBalance = {
	/** Amount of credit in balance. */
	amount: number;
	/** Currency of the credit balance. */
	currency: string;
};
export type BillingCoupon = {
	/** Coupon promotional code (if customer-facing) or coupon name. */
	code: string;
	/**
	 * Amount off the original value.
	 *
	 * Only one of `amount_off` and `percentage_off` will not be `null`.
	 */
	amount_off: number | null;
	/**
	 * Percentage off the original value.
	 *
	 * Only one of `amount_off` and `percentage_off` will not be `null`.
	 */
	percentage_off: number | null;
	/**
	 * Services, plans, and add-ons the coupon is applicable to.
	 * Applies to everything when `null`.
	 */
	applies_to: Array<Exclude<BillingPlan, "free"> | BillingService | BillingAddOn> | null;
	/** Restrictions for coupon usage. */
	restrictions?: {
		/** Whether the coupon can only be used on the first purchase. */
		only_first_time: boolean;
		/** Minimum value of the purchase so this coupon is applicable. */
		minimum_order_value: number | null;
	};
	/**
	 * Duration cycles for the coupon.
	 *
	 * Number is months, `once` means the coupon is only valid for one purchase or one billing.
	 */
	duration_cycles: number | "forever" | "once";
};
export type BillingPaymentMethod = {
	/** Credit card on record. */
	card: BillingPaymentMethodCard | null;
	/** Account balance in Stripe. */
	balance?: BillingPaymentMethodBalance;
	/** Coupon currently applied to the subscription. */
	coupon?: BillingCoupon;
};
export type BillingSubscriptionSummary = {
	/** Whether the subscription has an operation still being processed. */
	processing: boolean;
	/** Payment errors in the account's subscription. */
	payment_error: BillingPaymentError | null;
	/** Whether the subscription has a failing recurring payment. */
	past_due: boolean;
	/**
	 * Whether the subscription does not have enough account balance for the next
	 * recurring payment without a credit card on record.
	 */
	not_enough_balance: boolean;
	/** Whether the subscription has scheduled downgrades. */
	schedule: boolean;
};
export type BillingPaymentHistoryEntry = {
	/** Stripe ID for the history entry. Used for pagination. */
	stripe_id: string;
	/**
	 * Number of the invoice in Stripe for identification.
	 *
	 * May be `null` if Stripe does not provide it at the moment of the request.
	 */
	invoice_number?: string | null;
	/** Total cost of the invoice. */
	total: number;
	/** Currency used for the invoice. */
	currency: string;
	/**
	 * URL to download the invoice and receipt on Stripe.
	 *
	 * May be `null` if Stripe does not provide it at the moment of the request.
	 */
	receipt_url?: string | null;
	/** Whether the invoice was paid. */
	paid: boolean;
	/** Payment status of the invoice. */
	status: string;
	/** Information for the credit card used to pay the invoice. */
	card: {
		/** Credit card brand. */
		brand: string | null;
		/** Credit card's last four digits. */
		last4: string | null;
	} | null;
	/** Timestamp for when the invoice was created. */
	created_at: string;
};
export type BillingInformation = {
	/** Account ID. */
	account: GenericID;
	/** Company registered in account's billing information. */
	company: string;
	/** Country registered in account's billing information. */
	country: string | null;
	/** State registered in account's billing information. */
	state: string | null;
	/** City registered in account's billing information. */
	city: string | null;
	/** Street address registered in account's billing information. */
	street: string | null;
	/** Zip code registered in account's billing information. */
	zip_code: string | null;
	/** Extra information to be attached to the invoice for tax and other purposes. */
	comments: string | null;
	/** Payment method registered in account's billing information. */
	payment_method: BillingPaymentMethod | null;
	/** Timestamp when the billing information was last updated. */
	updated_at: string;
};
export type BillingEditInformation = Partial<Omit<BillingInformation, "account" | "updated_at" | "payment_method">>;
export type BillingResourceAllocationServices = Record<BillingService, number>;
export type BillingProfileResourceAllocation = {
	/** Profile ID. */
	profile: GenericID;
	/** Timestamp when the resource allocation for the profile was last updated. */
	updated_at: string;
} & BillingResourceAllocationServices;
export type BillingResourceAllocation = BillingProfileResourceAllocation[];
export type BillingEditResourceAllocation = Array<Partial<Omit<BillingProfileResourceAllocation, "updated_at">>>;
export interface ProfileListInfo {
	id: GenericID;
	name: string;
	logo_url: string | null;
	from_share?: boolean;
	account?: GenericID;
}
export interface ProfileLimit {
	input: number;
	output: number;
	sms: number;
	email: number;
	analysis: number;
	data_records: number;
	run_users: number;
	push_notification: number;
	file_storage: number;
}
export type ProfileAddOns = {
	/** Whether the profile has the Custom Domain add-on purchased. */
	custom_dns: boolean;
	/** Whether the profile has the Custom Mobile App add-on purchased. */
	mobile: boolean;
};
export interface ProfileInfo {
	info: {
		id: GenericID;
		account: GenericID;
		name: string;
		logo_url: string | null;
		banner_url: string | null;
		created_at: Date;
		updated_at: Date;
	};
	allocation: ProfileLimit;
	addons: ProfileAddOns;
	account_plan: string;
}
export interface ProfileSummary {
	limit: ProfileLimit;
	amount: {
		device: number;
		bucket: number;
		dashboard: number;
		dashboard_shared: number;
		analysis: number;
		action: number;
		am: number;
		run_users: number;
		dictionary: number;
		connectors: number;
		networks: number;
		tcore: number;
	};
	limit_used: {
		input: number;
		output: number;
		analysis: number;
		sms: number;
		email: number;
		data_records: number;
		run_users: number;
		push_notification: number;
		file_storage: number;
		tcore: number;
	};
	addons: ProfileAddOns;
}
/**
 * Type for a single usage statistic with timestamp.
 *
 * Not all of the services will be present for every statistic, only if for the usage period the service was used.
 */
export type UsageStatistic = Partial<Record<BillingService, number>> & {
	/** Timestamp for the usage statistic. */
	time: Date;
};
export interface AuditLog {
	events?: {
		resourceName: string;
		message: string;
		resourceID: GenericID;
		who: GenericID;
		date: Date;
	}[];
	statistics?: {
		recordsMatched: number;
		recordsScanned: number;
		bytesScanned: number;
	};
	status?: "Running" | "Complete" | "Failed" | "Timeout" | "Unknown";
	queryId: string;
}
export type resourceNameType = "action" | "am" | "analysis" | "connector" | "dashboard" | "device" | "dictionary" | "network" | "profile" | "run" | "runuser";
export interface AuditLogFilter {
	resourceID?: GenericID;
	resourceName?: resourceNameType;
	find?: "*" | string;
	start_date?: Date;
	end_date?: Date;
	limit?: number;
}
export interface AddonInfo {
	id: GenericID;
	name: string;
	logo_url: string | null;
}
export type DateFixed = {
	/** Timestamp for fetching the hourly statistics in a day. */
	date?: string | Date | undefined;
};
export type DateRange = {
	/** Starting date for fetching statistics in a interval. */
	start_date: string | Date;
	/** End date for fetching statistics in a interval. */
	end_date: string | Date;
	/**
	 * Periodicity of the statistics to fetch.
	 *
	 * @default "hour"
	 */
	periodicity: "hour" | "day" | "month";
};
export type StatisticsDate = {
	/**
	 * Timezone to be used in the statistics entries.
	 *
	 * @default "UTC"
	 */
	timezone?: string;
} & (DateFixed | DateRange);
export type ProfileTeam = {
	active: boolean;
	created_at: Date;
	email: string;
	id: string;
	name: string;
};
export interface AccountCreateInfo {
	/** Name of the account */
	name: string;
	/** Email of the account */
	email: string;
	/** Password of the account */
	password: string;
	/** Password confirmation */
	cpassword: string;
	/** Country of the account */
	country?: string;
	/** Timezone of the account */
	timezone: string;
	/** Company of the account */
	company?: string;
	/** Set true if wanna receive newsletter */
	newsletter?: boolean;
	developer?: boolean;
}
export interface AccountInfo extends Omit<AccountCreateInfo, "password" | "cpassword" | "country"> {
	active: boolean;
	blocked: boolean;
	id: GenericID;
	/** language set e.g "en-us" */
	language: string;
	last_login: Date | null;
	options: {
		user_view_welcome: boolean;
		/** How decimal values are separated */
		decimal_separator: string;
		thousand_separator: string;
		last_whats_new: Date | null;
	};
	phone: string | null;
	send_invoice: boolean;
	stripe_id: string | null;
	/** Type of the account e.g "user" */
	type: string;
	/** Plan of the account e.g  "free" | "starter" | "scale" */
	plan: string;
	created_at: Date;
	updated_at: Date;
	/** One-Time Password (OTP) settings */
	otp?: {
		authenticator: boolean;
		sms: boolean;
		email: boolean;
	};
}
export interface LoginResponse {
	type: string;
	id: GenericID;
	email: string;
	company: string;
	name: string;
	profiles: Required<ProfileListInfo>[];
}
export interface LoginCredentials {
	email: string;
	password: string;
	otp_type: OTPType;
	pin_code: string;
}
export type OTPType = "sms" | "email" | "authenticator";
export interface TokenCreateInfo {
	/** Id of profile to create the token */
	profile_id: GenericID;
	/** Email of the account */
	email: string;
	/** Password of the account */
	password: string;
	/** OTP Pin Code */
	pin_code: string;
	/** OTP Type */
	otp_type: OTPType;
	/** Name of the token */
	name: string;
}
export type ActionType = "condition" | "resource" | "interval" | "schedule" | "mqtt_topic" | "usage_alert" | "condition_geofence";
export type TriggerGeofenceValueType = {
	/** E.g [longitude, latitude] */
	center?: number[];
	radius?: number;
	/** E.g [[longitude, latitude], [longitude, latitude], ...] */
	coordinates?: number[][];
};
export type ContentVariables = {
	name: string;
	value: string;
};
export type ActionTypeParams = {
	script: GenericID[];
	type: "script";
} | {
	message: string;
	subject: string;
	type: "notification";
} | {
	message: string;
	subject: string;
	run_user: GenericID;
	type: "notification_run";
} | {
	message: string;
	subject: string;
	to: string;
	type: "email";
} | {
	message: string;
	to: string;
	type: "sms";
} | {
	bucket: string;
	payload: string;
	topic: string;
	type: "mqtt";
} | {
	headers: Record<string, any>;
	type: "post";
	url: string;
} | {
	type: "sms-twilio";
	message: string;
	to: string;
	from: string;
	twilio_sid: GenericID;
	twilio_token: GenericID;
} | {
	type: "whatsapp-twilio";
	message: string;
	to: string;
	from: string;
	twilio_sid: GenericID;
	twilio_token: GenericID;
	content_variables: ContentVariables[];
	content_sid: GenericID;
} | {
	type: "email-sendgrid";
	from: string;
	message: string;
	subject: string;
	to: string;
	sendgrid_api_key: GenericID;
} | {
	type: "email-smtp";
	from: string;
	message: string;
	subject: string;
	to: string;
	smtp_secret: GenericID;
} | {
	type: "queue-sqs";
	sqs_secret: GenericID;
	batch_enabled: boolean;
};
export type ActionTriggerType = {
	resource: "device" | "bucket" | "file" | "analysis" | "action" | "am" | "user" | "financial" | "profile";
	when: "create" | "update" | "delete";
	tag_key: string;
	tag_value: string;
} | {
	interval: string;
} | {
	timezone: string | Date;
	/** The cron expression */
	cron: string;
} | {
	device: string;
	variable: string;
	is: Conditionals;
	value: string;
	second_value?: string;
	value_type: "string" | "number" | "boolean" | "*";
	unlock?: boolean;
} | {
	service_or_resource: "input" | "output" | "analysis" | "data_records" | "sms" | "email" | "run_users" | "push_notification" | "file_storage" | "device" | "dashboard" | "action" | "tcore" | "team_members" | "am";
	condition: "=" | ">";
	condition_value: number;
} | {
	device: string;
	variable: string;
	is: "IN" | "OUT";
	value: TriggerGeofenceValueType;
	unlock?: boolean;
};
export interface ActionCreateInfo {
	/** The name for the action. */
	name: string;
	/** Profile identification */
	profile?: GenericID;
	/** True if the action is active or not. The default is true. */
	active?: boolean;
	/** An array of tags. */
	tags?: TagsObj[];
	/** Description of the action. */
	description?: string | null;
	lock?: boolean;
	/** Type of action */
	type?: ActionType;
	/** Array of trigger configuration according to type */
	trigger?: ActionTriggerType[];
	/** Action configuration */
	action: ActionTypeParams;
	/** Action action. */
	id?: GenericID;
	/** Trigger the action when unlock condition is met. */
	trigger_when_unlock?: boolean;
}
export interface ActionInfo extends ActionCreateInfo {
	id: GenericID;
	last_triggered: ExpireTimeOption;
	updated_at: Date;
	created_at: Date;
}
export interface MQTTResourceAction {
	client_id: string;
	connected_at: string;
	disconnect_at?: string;
}
export type ActionQuery = Query<ActionInfo, "name" | "active" | "last_triggered" | "created_at" | "updated_at">;
export interface ScriptFile {
	name: string;
	content: Base64;
	language: RunTypeOptions;
}
export interface AnalysisCreateInfo {
	name: string;
	description?: string | null;
	interval?: string;
	run_on?: "tago" | "external";
	file_name?: string;
	runtime?: RunTypeOptions;
	active?: true;
	profile?: GenericID;
	/** Environment variables */
	variables?: {
		key: string;
		value: string | number | boolean;
	};
	tags?: TagsObj[];
}
export interface VersionsAnalysis {
	[version_number_key: string]: {
		file_name: string;
		created_at: Date | string;
		/** E.g John Doe (john.doe@email.com)  */
		created_by: string;
	};
}
export interface AnalysisInfo extends AnalysisCreateInfo {
	id: GenericID;
	token: string;
	last_run: ExpireTimeOption;
	created_at: Date;
	updated_at: Date;
	locked_at: any;
	console?: string[];
	/** Current version being used */
	version?: number | string;
	versions?: VersionsAnalysis;
}
export type AnalysisQuery = Query<AnalysisInfo, "name" | "active" | "run_on" | "last_run" | "created_at" | "updated_at">;
export type AnalysisListItem<T extends AnalysisQuery["fields"] extends readonly (keyof any)[] ? AnalysisQuery["fields"][number] : keyof AnalysisInfo = keyof AnalysisInfo> = Pick<AnalysisInfo, T> & Partial<AnalysisInfo>;
/**
 * Available runtime environments for snippets
 */
export type SnippetRuntime = "node-legacy" | "python-legacy" | "python-rt2025" | "deno-rt2025";
/**
 * Individual snippet metadata
 */
export interface SnippetItem {
	/** Unique identifier for the snippet */
	id: string;
	/** Human-readable title */
	title: string;
	/** Description of what the snippet does */
	description: string;
	/** Programming language (typescript, javascript, python) */
	language: string;
	/** Array of tags for categorization */
	tags: string[];
	/** Filename of the snippet */
	filename: string;
	/** Full path to the file in the runtime directory */
	file_path: string;
}
/**
 * API response containing all snippets metadata for a runtime
 */
export interface SnippetsListResponse {
	/** Runtime environment identifier */
	runtime: SnippetRuntime;
	/** Schema version for the API response format */
	schema_version: number;
	/** ISO timestamp when the response was generated */
	generated_at: string;
	/** Array of all available snippets for this runtime */
	snippets: SnippetItem[];
}
export type ExportBucket = {
	id: string;
	origin: string;
	variables: string[];
}[];
export interface ExportBucketOption {
	start_date?: Date;
	end_date?: Date;
}
export interface BucketCreateInfo {
	/** A name for the bucket. */
	name: string;
	/** Description for the bucket. */
	description?: string | undefined;
	/** Set if the bucket will be visible or not. Default True. */
	visible?: boolean;
	/** An array of tags. */
	tags?: TagsObj[];
}
/**
 * Type of data storage for a device (bucket).
 */
export type DataStorageType = "immutable" | "mutable" | "legacy";
export type ChunkPeriod = "day" | "week" | "month" | "quarter";
export interface BucketInfoBasic extends BucketCreateInfo {
	id: GenericID;
	/** Data storage type for the bucket. */
	profile: GenericID;
	last_retention: string | undefined;
	created_at: Date;
	updated_at: Date;
	chunk_period?: ChunkPeriod;
	chunk_retention?: number;
	data_retention?: string;
	data_retention_ignore?: [
	];
}
export type BucketInfoImmutable = Omit<BucketInfoBasic, "data_retention" | "data_retention_ignore"> & {
	type: "immutable";
	/**
	 * Chunk division to retain data in the device.
	 *
	 * Always returned for Immutable devices.
	 */
	chunk_period: ChunkPeriod;
	/**
	 * Amount of chunks to retain data according to the `chunk_period`.
	 *
	 * Always returned for Immutable devices.
	 */
	chunk_retention: number;
};
export type BucketInfoMutable = Omit<BucketInfoBasic, "chunk_period" | "chunk_retention" | "data_retention" | "data_retention_ignore"> & {
	type: "mutable";
};
/**
 * @deprecated
 */
export type BucketInfoLegacy = Omit<BucketInfoBasic, "chunk_period" | "chunk_retention"> & {
	type: "legacy";
	data_retention: string;
	data_retention_ignore: [
	];
};
export type BucketInfo = BucketInfoImmutable | BucketInfoMutable | BucketInfoLegacy;
export interface BucketDeviceInfo {
	id: GenericID;
	name: string;
}
export interface VariablesInfo {
	variable: string;
	origin: GenericID;
	origin_name?: string;
	amount?: number;
	deleted?: {
		origin: string;
		created_at: string;
	}[];
}
export interface ListVariablesOptions {
	/** return amount of each variable */
	showAmount?: boolean;
	/** return array of async deleted */
	showDeleted?: boolean;
	/** Change origins to array of object with id and name */
	resolveOriginName?: boolean;
}
export type BucketQuery = Query<BucketInfo, "name" | "visible" | "data_retention" | "created_at" | "updated_at">;
export interface Arrangement {
	widget_id: string;
	x: number;
	y: number;
	width: number;
	height: number;
	tab?: string | null;
}
export interface DashboardCreateInfo {
	label: string;
	arrangement?: Arrangement[];
	tags?: TagsObj[];
	visible?: boolean;
}
export interface DashboardInfo extends DashboardCreateInfo {
	id: GenericID;
	created_at: Date;
	updated_at: Date;
	last_access: Date | null;
	group_by: [
	];
	tabs: [
	];
	icon: {
		url: string;
		color?: string;
	};
	background: any;
	type: string;
	blueprint_device_behavior: "more_than_one" | "always";
	blueprint_selector_behavior: undefined | "open" | "closed" | "always_open" | "always_closed";
	blueprint_devices: [
		{
			conditions: [
				{
					key: string;
					value: string;
				}
			];
			name: string;
			id: string;
			label?: string;
			filter_conditions?: [
				{
					blueprint_device: string;
					tag_key: string;
					type: string;
				}
			];
		}
	];
	theme: any;
	setup: any;
	shared: {
		id: string;
		email: string;
		name: string;
		free_account: boolean;
		allow_tags: boolean;
		expire_time: string;
		allow_share: boolean;
	};
}
export interface WidgetData {
	origin: GenericID;
	qty?: number;
	timezone?: string;
	variables?: string;
	bucket?: GenericID;
	query?: "min" | "max" | "count" | "avg" | "sum";
	start_date?: Date | string;
	end_date?: Date | string;
	overwrite?: boolean;
}
export interface WidgetResource {
	filter: TagsObj[];
}
export type ResourceTag = `tags.${string}`;
export type ResourceParam = `param.${string}`;
export type DeviceResourceView = ResourceTag | ResourceParam | "name" | "id" | "bucket_name" | "network_name" | "connector_name" | "connector" | "network" | "bucket" | "last_input" | "created_at" | "active";
export interface WidgetDeviceResource extends WidgetResource {
	type: "device";
	view: DeviceResourceView;
	editable: "name" | ResourceTag | ResourceParam;
}
/**
 * Allowed keys: tags.\* or param.\*
 *
 * The value must always be a string or boolean.
 */
export type EditDeviceResource = {
	device: GenericID;
	name?: string;
	active?: boolean;
} & {
	[key: string]: string | boolean;
};
export interface EditResourceOptions {
	/** Identifier to send to the Analysis scope in `widget_exec`. */
	identifier?: string;
}
export interface WidgetInfo {
	analysis_run?: GenericID;
	dashboard?: GenericID;
	display: any;
	data?: WidgetData[];
	resource?: WidgetDeviceResource[];
	id?: GenericID;
	label: string;
	realtime?: boolean | null;
	type: string;
}
export interface DevicesRelated extends BucketDeviceInfo {
	bucket: GenericID;
}
export interface AnalysisRelated {
	id: GenericID;
	name: string;
}
export interface PostDataModel extends Omit<Data, "id" | "created_at"> {
	origin: GenericID;
	variable: string;
}
export interface GetDataModel {
	overwrite?: widgetOverwrite;
	blueprint_devices?: {
		origin: GenericID;
		id: GenericID;
		bucket?: GenericID;
	}[];
	page?: number;
	amount?: number;
}
export type EditDataModel = PostDataModel & {
	id: GenericID;
};
export type DashboardQuery = Query<DashboardInfo, "name" | "label" | "active" | "created_at" | "updated_at">;
export type PublicKeyResponse = {
	token: GenericToken$1;
	expire_time: ExpireTimeOption;
};
export type widgetOverwriteOptions = "start_date" | "end_date" | "timezone";
export type widgetOverwrite = {
	[key in widgetOverwriteOptions]: any;
};
export interface DeviceQuery extends Query<DeviceInfo, "name" | "visible" | "active" | "last_input" | "created_at" | "updated_at"> {
	resolveBucketName?: boolean;
	resolveConnectorName?: boolean;
	serial?: string;
}
export interface DeviceCreateInfoBasic {
	/** Device name. */
	name: string;
	/** Connector ID. */
	connector: GenericID;
	/** Network ID. */
	network: GenericID;
	/**
	 * Device's data storage (bucket) type.
	 *
	 * @default "legacy"
	 */
	type?: DataStorageType;
	/** Description of the device. */
	description?: string | null;
	/** Set if the device will be active. */
	active?: boolean;
	/** Set if the device will be visible. */
	visible?: boolean;
	/** An array of configuration params */
	configuration_params?: ConfigurationParams[];
	/** An array of tags */
	tags?: TagsObj[];
	/** Device serial number. */
	serie_number?: string;
	/** If device will use connector parser */
	connector_parse?: boolean;
	/** Javascript code for use as payload parser */
	parse_function?: string;
}
export interface DeviceCreateInfoMutable extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "mutable";
}
export interface DeviceCreateInfoImmutable extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "immutable";
	/**
	 * Chunk division to retain data in the device.
	 *
	 * Required for Immutable devices.
	 */
	chunk_period: "day" | "week" | "month" | "quarter";
	/**
	 * Amount of chunks to retain data according to the `chunk_period`.
	 * Integer between in the range of 0 to 36 (inclusive).
	 *
	 * Required for Immutable devices.
	 */
	chunk_retention: number;
}
/**
 * @deprecated
 */
export interface DeviceCreateInfoLegacy extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "legacy";
}
export type DeviceCreateInfo = DeviceCreateInfoLegacy | DeviceCreateInfoMutable | DeviceCreateInfoImmutable;
export type DeviceEditInfo = Partial<Omit<DeviceCreateInfo, "chunk_period" | "type"> & {
	chunk_retention: number;
}>;
export interface DeviceInfoBase {
	/** Device ID. */
	id: GenericID;
	/** ID of the profile that owns the device. */
	profile: GenericID;
	/**
	 * Bucket storing the device's data.
	 *
	 * @deprecated
	 */
	bucket: {
		id: GenericID;
		name: string;
	};
	/**
	 * Payload parser.
	 *
	 * Encoded string when enabled, `null` when not enabled.
	 */
	payload_decoder: string | null;
	/** Date for the device's creation. */
	created_at: Date;
	/** Date for the device's last update. */
	updated_at: Date;
	/** Date for the device's last input. */
	last_input: Date | null;
	/**
	 * Device-specific soft limits on RPM.
	 *
	 * `rpm` is `null` when not set or when the profile doesn't have the add-on.
	 */
	rpm: {
		data_input?: number;
		data_output?: number;
	} | null;
}
export type DeviceInfoImmutable = Required<DeviceInfoBase & Omit<DeviceCreateInfoImmutable, "configuration_params" | "serie_number" | "connector_parse" | "parse_function">>;
export type DeviceInfoMutable = Required<DeviceInfoBase & Omit<DeviceCreateInfoMutable, "configuration_params" | "serie_number" | "connector_parse" | "parse_function">>;
export type DeviceInfo = DeviceInfoImmutable | DeviceInfoMutable;
export interface ConfigurationParams {
	sent: boolean;
	key: string;
	value: string;
	id?: string;
}
export type DeviceCreateResponse = {
	device_id: GenericID;
	bucket_id: GenericID;
	token: GenericToken$1;
};
export type DeviceListItem<T extends DeviceQuery["fields"] extends readonly (keyof any)[] ? DeviceQuery["fields"][number] : keyof DeviceInfo = keyof DeviceInfo> = Pick<Omit<DeviceInfo, "bucket"> & {
	bucket: GenericID;
}, "id" | "name" | "tags" | T> & Partial<DeviceInfo>;
export interface DeviceTokenData {
	token: GenericToken$1;
	device_id: GenericID;
	network_id: GenericID;
	name: string;
	permission: PermissionOption;
	serie_number: string | undefined;
	last_authorization: string | undefined;
	expire_time: ExpireTimeOption;
	created_at: string;
}
export interface ListDeviceTokenQuery extends Query<DeviceTokenDataList, "name" | "permission" | "serie_number" | "last_authorization" | "created_at"> {
}
export type DeviceTokenDataList<T extends ListDeviceTokenQuery["fields"] extends readonly (keyof any)[] ? ListDeviceTokenQuery["fields"][number] : keyof DeviceTokenData = keyof DeviceTokenData> = Pick<DeviceTokenData, T> & Partial<DeviceTokenData>;
export interface DeviceChunkData {
	amount: number | null;
	id: string;
	from: string;
	to: string;
}
export interface DeviceDataRestore {
	deviceID: GenericID;
	file_address: string;
	notification?: boolean;
}
export interface DeviceDataBackup {
	deviceID: GenericID;
	/**
	 *
	 * The file address is the string template used to compose,
	 * the chunk's file path on TagoIO Files.
	 *
	 * You can use the keys $DEVICE$, $CHUNK$, $FROM$ and $TO$ that
	 * will be automatically replaced when building the path.
	 *
	 * $DEVICE$ - Device ID
	 *
	 * $CHUNK$ - Chunk ID
	 *
	 * $FROM$ - The chunk from date (ex: 2022-05-1)
	 *
	 * $TO$ - The chunk to date (ex: 2022-05-2)
	 *
	 * @example
	 *
	 * /devices/$DEVICE$/$FROM$_$TO$
	 *
	 */
	file_address: string;
	/**
	 *
	 * Enable headers to the CSV-generated files.
	 * Headers will describe the variable's
	 * data in each column.
	 */
	headers?: boolean;
}
export interface DeviceDataBackupResponse {
	chunk_id?: string;
	file_address: string;
	status: "scheduled";
}
/** @deprecated */
export interface DeviceChunkParams {
	deviceID: GenericID;
	chunkID: string;
	/**
	 *
	 * Enable headers to the CSV-generated files.
	 * Headers will describe the variable's
	 * data in each column.
	 */
	headers: boolean;
	/**
	 *
	 * The file address is the string template used to compose,
	 * the chunk's file path on TagoIO Files.
	 *
	 * You can use the keys $DEVICE$, $CHUNK$, $FROM$ and $TO$ that
	 * will be automatically replaced when building the path.
	 *
	 * $DEVICE$ - Device ID
	 *
	 * $CHUNK$ - Chunk ID
	 *
	 * $FROM$ - The chunk from date (ex: 2022-05-1)
	 *
	 * $TO$ - The chunk to date (ex: 2022-05-2)
	 *
	 * @example
	 *
	 * /devices/$DEVICE$/$FROM$_$TO$
	 *
	 */
	file_address: string;
}
/** @deprecated */
export interface DeviceChunkCopyResponse {
	chunk_id: string;
	file_address: string;
	status: "scheduled";
}
export interface DictionaryCreateInfo {
	name: string;
	slug: string;
	/** First dictionary language E.g "en-US" */
	fallback: string;
}
export interface DictionaryLanguage {
	/** Language code E.g "en-US" */
	code: string;
	active: boolean;
}
export interface DictionaryInfo extends DictionaryCreateInfo {
	id: GenericID;
	languages: DictionaryLanguage[];
	created_at: Date;
	updated_at: Date;
}
export interface LanguageData {
	[key: string]: string;
}
export interface LanguageEditData {
	dictionary: LanguageData;
	active: boolean;
}
export interface LanguageInfoQuery {
	fallback?: boolean;
}
export type DictionaryQuery = Query<DictionaryInfo, "name" | "slug" | "languages" | "fallback" | "created_at" | "updated_at">;
export type EntityFieldType = "uuid" | "string" | "int" | "float" | "json" | "timestamp" | "text" | "boolean";
export type EntityFieldCreate = {
	action: "create";
	type?: EntityFieldType;
	required?: boolean;
};
export type EntityFieldRename = {
	action: "rename";
	new_name: string;
};
export type EntityFieldDelete = {
	action: "delete";
};
export type EntitySchema = Record<string, EntityFieldCreate | EntityFieldRename | EntityFieldDelete | Record<string, any>>;
export type EntityIndex = Record<string, {
	fields?: string[];
}>;
export type EntityCreateInfo = {
	name?: string;
	schema?: EntitySchema;
	index?: EntityIndex;
	tags?: TagsObj[];
	payload_decoder?: string | null;
};
export type EntityInfo = Required<EntityCreateInfo> & {
	id: string;
	profile: string;
	created_at: string;
	updated_at: string;
};
export interface EntityQuery extends Query<EntityInfo, "name" | "visible" | "active" | "last_input" | "created_at" | "updated_at"> {
	resolveBucketName?: boolean;
	resolveConnectorName?: boolean;
}
export type EntityListItem<T extends EntityQuery["fields"] extends readonly (keyof any)[] ? EntityQuery["fields"][number] : keyof EntityInfo = "id"> = Pick<EntityInfo, "id" | "name" | "tags" | T> & Partial<EntityInfo>;
export type EntityDataQuery = {
	/** Filters to narrow down the requests from the API. */
	filter?: Record<string, string | {
		start: string | null;
		end: string | null;
	}>;
	/** Amount of items to be fetched. */
	amount?: number;
	page?: number;
	/** Amount of items to be skipped. */
	skip?: number;
	/** Ordering for the requested data. */
	order?: any;
	/** Timestamp to pin the requested data to a specific start date. */
	startDate?: string;
	/** Timestamp to pin the requested data up to a specific end date. */
	endDate?: string;
	/** Index to use for the query. */
	index?: string;
};
export type EntityData = {
	id: GenericID;
} & Record<string, any>;
export type EntityUnknownData = {
	[field: string]: any;
};
export interface FileQuery {
	path?: string;
	paginationToken?: string;
	quantity?: number;
}
export interface FileListInfo {
	files: {
		filename: string;
		size: number;
		last_modified: Date | null;
	}[];
	folders: string[];
}
export interface Base64File {
	/** Name of file */
	filename: string;
	/** String of Base64 */
	file: string;
	/**
	 * Make file public
	 * default: false
	 */
	public?: boolean;
}
export interface CopyFiles {
	from: string;
	to: string;
}
export interface MoveFiles {
	from: string;
	to: string;
}
export interface FilesPermission {
	file: string;
	public: boolean;
}
export type UploadOptions = {
	/** the maximum amount of tries to upload each chunk to TagoIO. After this many unsuccessful tries of a single chunk, the upload is aborted */
	maxTriesForEachChunk?: number;
	/** timeout before trying to upload the same chunk if the request failed */
	timeoutForEachFailedChunk?: number;
	/** The file's content type. This is optional */
	contentType?: string;
	/** if the file can be accessed by anybody with a link or not */
	isPublic?: boolean;
	/**
	 * Dashboard ID.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	dashboard?: string;
	/**
	 * Widget ID.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	widget?: string;
	/**
	 * ID of the field from the widget where the file is selected.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	fieldId?: string;
	/** will provide a cancel token for you to cancel the request */
	onCancelToken?: (cancel: () => void) => any;
	/** the byte size of each chunk sent to TagoIO. This will influence how many requests this function will perform */
	chunkSize?: number;
	/** will provide the upload percentage for this file */
	onProgress?: (percentage: number) => any;
	/**
	 * map blueprint devices to real devices, so BP Device ID path is replaced by the real device ID
	 */
	blueprint_devices?: {
		origin: GenericID;
		id: GenericID;
		bucket?: GenericID;
	}[];
};
interface IDeviceParameters$1 {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	/** Optional only for dropdown */
	options?: any[];
}
export interface ConnectorCreateInfo {
	name?: string;
	description?: string;
	logo_url?: string;
	device_parameters?: IDeviceParameters$1[];
	networks?: GenericID[];
	payload_encoder?: string;
	/** Base64 decoded string */
	payload_decoder?: string;
	/** Refers to the **description** in the Documentation settings */
	install_text?: string;
	/** Refers to the **completion text** in the Documentation settings */
	install_end_text?: string;
	device_annotation?: string;
}
export interface ConnectorInfo extends ConnectorCreateInfo {
	id: GenericID;
	public: boolean;
	description?: string;
	logo_url?: string;
	created_at: Date;
	updated_at: Date;
	device_parameters?: IDeviceParameters$1[];
	networks?: GenericID[];
	/** Refers to the **description** in the Documentation settings */
	install_text?: string;
	/** Refers to the **completion text** in the Documentation settings */
	install_end_text?: string;
	device_annotation?: string;
}
export type ConnectorQuery = Query<ConnectorInfo, "name" | "id" | "description" | "logo_url" | "install_text" | "install_end_text" | "device_annotation" | "payload_decoder" | "networks">;
interface IDeviceParameters$2 {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	options?: any[];
}
export interface NetworkCreateInfo {
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters$2[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	/** Base64 decoded string */
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
	require_devices_access?: boolean;
}
export interface NetworkInfo extends NetworkCreateInfo {
	id: GenericID;
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters$2[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	/** Base64 decoded string */
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
}
export interface NetworkTokenInfo {
	name: string;
	token: GenericToken$1;
}
export interface NetworkTokenCreateResponse {
	token: GenericToken$1;
	name: string;
	network: GenericID;
}
export type NetworkQuery = Query<NetworkInfo, "name" | "description" | "logo_url" | "icon_url" | "banner_url" | "device_parameters" | "middleware_endpoint" | "payload_encoder" | "payload_decoder" | "serial_number" | "documentation_url" | "public" | "created_at" | "updated_at">;
export interface NotificationTriggerAnalysis {
	analysis_id: GenericID;
}
export interface NotificationTriggerHTTP {
	url: string;
	method: "POST" | "GET" | "PUT" | "DELETE" | "REDIRECT";
	body: {
		[key: string]: any;
	};
}
export interface NotificationTriggerProfile {
	share_profile: "accept" | "refuse";
}
export interface NotificationButton {
	id: string;
	label: string;
	color?: string;
	triggers: (NotificationTriggerAnalysis | NotificationTriggerHTTP | NotificationTriggerProfile)[];
}
export interface NotificationIconImage {
	image_url: string;
	bg_color?: HexColor;
	fit?: "fill" | "contain" | "cover";
}
export type HexColor = string;
export interface NotificationIconSVG {
	svg_url: string;
	svg_color?: HexColor;
	bg_color?: HexColor;
}
export interface NotificationCreate {
	title: string;
	message: string;
	read?: boolean;
	icon?: NotificationIconSVG | NotificationIconImage;
	buttons?: NotificationButton[];
	buttons_enabled?: boolean;
	buttons_autodisable?: boolean;
}
export type NotificationQuery = Query<{
	read: boolean;
}, "created_at">;
export type NotificationInfo = {
	id: GenericID;
	created_at: Date;
} & Required<NotificationCreate>;
export interface PaymentInfo {
	status: boolean;
	result: [
		{
			id: GenericID;
			stripe_id: GenericID;
			account: GenericID;
			info: string;
			notes: string;
			invoice_number: number;
			invoice_code: string;
			total: number;
			due_date: string;
			payment_method: string;
			created_at: string;
			updated_at: string;
			paid: true;
			ref_account: {
				name: string;
				email: string;
				id: GenericID;
				send_invoice: boolean;
			};
			ref_payment_method: {
				last4: string;
				brand: string;
			};
			account_invoice_items: {
				unit_value: number;
				description: string;
				qty: number;
				value: number;
			}[];
		}
	];
}
export interface PlanSetInfo {
	plan: string;
	sms?: number;
	email?: number;
	data_records?: number;
	device_request?: number;
	analysis?: number;
}
export interface PlanInfo extends PlanSetInfo {
	id: GenericID;
	active: number;
	end_date: Date | null;
	price: number;
	created_at: Date;
	next_plan: string;
}
export interface ProfileWithLimit {
	id: GenericID;
	name: string;
	limits: {
		input: number;
		output: number;
		sms: number;
		email: number;
		analysis: number;
		data_records: number;
	};
	addons: object;
}
export interface Discount {
	description: string;
	value: number;
	expire_at: ExpireTimeOption;
}
export interface Summary {
	profiles: ProfileWithLimit[];
	plan: string;
	discounts: Discount[];
}
export interface Price {
	price: number;
	amount: number;
}
export interface CurrentPrices {
	analysis: Price[];
	data_records: Price[];
	sms: Price[];
	output: Price[];
	input: Price[];
	email: Price[];
	plans: {
		name: string;
		price: number;
	}[];
	addons: {
		name: string;
		price: number;
	}[];
}
export interface RunInfo {
	profile: GenericID;
	active: boolean;
	name: string;
	sub_title: string;
	url: string;
	email_domain: string | null;
	signup_method: string;
	favicon: string | null;
	logo: string | null;
	signup_logo: string | null;
	signup_logo_options: object;
	sidebar_buttons: {
		color: string;
		href: string;
		iconUrl: string;
		text: string;
		type: string;
		value?: string;
	}[];
	signup_fields: {
		name: string;
		placeholder: string;
		required: boolean;
		type: string;
	}[];
	email_templates: {
		[email_template_key: string]: {
			subject: string;
			value: string;
		};
	};
	feature_devicewifisetup: {
		background_color: string;
		button_cancel_background_color: string;
		button_cancel_text_color: string;
		button_confirm_background_color: string;
		button_confirm_text_color: string;
		enabled: boolean;
		ip: string;
		language: string;
		name: string;
		port: string;
		protocol: string;
		text_color: string;
		translations: {
			[language: string]: object;
		};
	};
	feature_geolocation: {
		buffer_size: number;
		device: string | null;
		enabled: boolean;
		middleware_url: string;
		minimum_distance: number;
		minimum_interval: number;
		target: string;
	};
	theme: {
		[option in ThemeOption]: string;
	};
	integration: object;
	sso_saml_active: boolean;
	security: {
		otp: {
			authenticator: boolean;
			sms: boolean;
			email: boolean;
		};
	};
	signin_buttons: {
		label: string;
		type: "link";
		url: string;
	}[];
	anonymous_token: string;
	/** Time to live for the token. */
	auth_token_ttl: string;
	dictionary: GenericID;
}
export interface UserOptions {
	decimal_separator?: string;
	thousand_separator?: string;
	date_format?: string;
	time_format?: string;
}
export interface UserCreateInfo {
	name: string;
	email: string;
	password: string;
	timezone: string;
	company?: string;
	phone?: string;
	language?: string;
	tags?: TagsObj[];
	active?: boolean;
	options?: UserOptions;
}
export interface UserCreateResponse {
	user: GenericID;
}
export interface UserInfo extends Omit<UserCreateInfo, "password"> {
	id: GenericID;
	profile: GenericID;
	active: boolean;
	newsletter: boolean;
	last_login: Date | null;
	created_at: Date;
	updated_at: Date;
	options: object;
	tags: TagsObj[];
}
export interface LoginResponseRun {
	token: GenericToken$1;
	name: string;
	/** Run user ID */
	run_user: string;
	expire_date: ExpireTimeOption;
	created_at: string;
}
export interface LoginAsUserOptions {
	/**
	 * Date to expire the login token.
	 *
	 * @example
	 * "3 months", "1 year", "20 hours"
	 * @default "8 hours"
	 */
	expire_time?: string;
}
export interface SAMLAttributeMappings {
	email: string;
	firstName: string;
	lastName?: string;
	phone?: string;
	company?: string;
	language?: string;
	timezone?: string;
	tags?: {
		[tag: string]: string;
	};
}
export interface RunSAMLInfo {
	/** Information for TagoIO's API routes to use as a Service Provider in SAML authentication flows. */
	sp: {
		entity_id: string;
		acs_url: string;
		metadata: string;
	};
	/** Relevant information from the Identity Provider's metadata after being parsed by TagoIO. */
	idp: {
		issuer: string;
	};
	/** Attribute mappings for the Identity Provider's attributes to the attributes used in TagoIO. */
	mapping: SAMLAttributeMappings;
}
export interface RunSAMLEditInfo {
	/** Identity Provider's XML metadata encoded in a base 64 string. */
	idp_metadata?: string;
	/** Attribute mappings for the Identity Provider's attributes to the attributes used in TagoIO. */
	mapping?: SAMLAttributeMappings;
}
export type CustomDomainDnsRecord = {
	/**
	 * Status for the DNS record check.
	 *
	 * When `true`, the DNS record is properly configured with the provided key and value.
	 * When `false`, the DNS record is either not yet configured or the `key` exists but the
	 * value in the DNS record does not match the `value` provided.
	 */
	status: boolean;
	/** Type of the DNS record. */
	type: string;
	/** Key for key-value pair in the DNS record. */
	key: string;
	/** Value for the key-value pair the DNS record. */
	value: string;
	/**
	 * Current value in the provider's record for the DNS record's `key`.
	 *
	 * Only returned when the DNS record has the matching `key` configured.
	 *
	 * When `status` is `true`, the value here will be the same as the one in `value`.
	 * When `status` is `false`, the value here can is either stale or there was an error
	 * copying the provided `value` in the DNS provider's record.
	 */
	current_value?: string;
};
/**
 * Type for the Custom Domain response from the API, unparsed.
 *
 * @internal
 */
export interface CustomDomainResponse {
	/**
	 * Whether the custom domain is active.
	 *
	 * This is only `true` when all the required DNS records are properly configured in the DNS provider.
	 */
	active: boolean;
	/** Configured domain for the RUN. */
	domain: string;
	/** Configured subdomain for the RUN. */
	subdomain: string;
	/** Mailing address for the RUN with custom domain. */
	email: string;
	/**
	 * DNS record for the SSL certificate.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_ssl: CustomDomainDnsRecord;
	/**
	 * DNS record for the page endpoint.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_page: CustomDomainDnsRecord;
	/**
	 * First DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_1: CustomDomainDnsRecord;
	/**
	 * Second DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_2: CustomDomainDnsRecord;
	/**
	 * Third DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_3: CustomDomainDnsRecord;
	/** Timestamp (in string format) for when the custom domain was configured. */
	created_at: string;
}
/**
 * Type for the Custom Domain information in a profile's RUN.
 */
export interface CustomDomainInfo extends Omit<CustomDomainResponse, "created_at"> {
	/** Timestamp for when the custom domain was configured. */
	created_at: Date;
}
/**
 * Type for the data required to configure a profile's RUN Custom Domain.
 */
export interface CustomDomainCreate {
	/**
	 * Domain for the RUN's custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this will be `"mycompany.com"`.
	 */
	domain: string;
	/**
	 * Subdomain for the RUN's custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this will be `"portal"`.
	 */
	subdomain: string;
	/**
	 * Mailing address for the RUN with custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this can be either
	 * `"portal.mycompany.com"` or `"mycompany.com"`.
	 */
	email: string;
}
export type ThemeOption = "actionSchedule" | "actionTriggerByData" | "actionTriggerByResource" | "actionTriggerByMQTT" | "alertDangerBackground" | "alertInfoBackground" | "alertWarningBackground" | "analysisExternal" | "analysisInternal" | "buttonDanger" | "buttonDangerText" | "buttonDefault" | "buttonDefaultText" | "buttonDisabled" | "buttonDisabledText" | "buttonIconLabel" | "buttonPrimary" | "buttonPrimaryText" | "buttonSuccess" | "buttonSuccessText" | "buttonWarning" | "buttonWarningText" | "deviceInputOutput1Day" | "deviceInputOutput3Days" | "deviceInputOutput3Hours" | "deviceInputOutput6Hours" | "deviceInputOutputRest" | "dottedBorder" | "dropdownAccent" | "dropdownBackground" | "floatingSidebarTitle" | "footerBackground" | "formControlBorder" | "gaugeEmpty" | "gaugeFill" | "gaugePrimaryText" | "gaugeSecondaryText" | "iconRadioSelected" | "iconRadioSubTitle" | "informationIcon" | "inputBackground" | "inputBackgroundReadOnly" | "inputError" | "inputForeground" | "inputForegroundReadOnly" | "lightBorder" | "limitAlert" | "link" | "listNavColor" | "listTitleLabel" | "loading" | "loginButton" | "loginButtonText" | "loginForeground" | "loginForm" | "modalContainer" | "modalOverlay" | "navbar" | "navbarBetaDeveloperBorder" | "navbarButton" | "navbarDropdownBorder" | "navbarDropdownOption" | "navbarDropdownOptionBorder" | "navbarText" | "navDescription" | "notificationButtonAmount" | "notificationButtonAmountText" | "notificationFilterBackground" | "notificationFooter" | "notificationItemBorder" | "notificationItemDate" | "notificationItemTextAccepted" | "notificationItemUnread" | "primary" | "publicPageNavigationBar" | "sidebarAccessSelected" | "sidebarAccountSelected" | "sidebarActionSelected" | "sidebarAnalysisSelected" | "sidebarBackground" | "sidebarBillingSelected" | "sidebarBucketSelected" | "sidebarDashboardSelected" | "sidebarDeviceSelected" | "sidebarExploreSelected" | "sidebarFileSelected" | "sidebarForegroundIcon" | "sidebarForegroundText" | "sidebarHomeSelected" | "sidebarItem" | "sidebarRibbon" | "sidebarRunSelected" | "sidebarSeparator" | "sidebarSeparatorForeground" | "sidebarUserSelected" | "snakeButtonOutline" | "svgTagoFont" | "svgTagoIOHole" | "switchDisabledBackground" | "switchSlider" | "tabBackground" | "tabLabelBorder" | "tooltipContainer" | "tooltipText" | "verticalTabItem" | "verticalTabItemBorder" | "widgetCardBackground" | "widgetIconsAccent" | "widgetIconsBackground" | "widgetIconsColor" | "widgetIconsFooterBasic" | "widgetIconsFooterPremium" | "auth_bg_opacity" | "auth_bg_src" | "auth_bg_type" | "auth_form_opacity";
export type UserQuery = Query<UserInfo, "name" | "active" | "last_login" | "created_at" | "updated_at">;
export type UserListItem<T extends UserQuery["fields"] extends readonly (keyof any)[] ? UserQuery["fields"][number] : keyof UserInfo = keyof UserInfo> = Pick<UserInfo, T> & Partial<UserInfo>;
/**
 * Token used on TagoIO, string with 34 characters
 */
type GenericToken = string;
type TokenCreateResponse = {
	token: GenericToken;
	name: string;
	profile: GenericID;
	/** [Optional] Verification code to validate middleware requests. */
	additional_parameters?: string;
};
export type SecretsValue = {
	value: string;
};
export interface SecretsInfo {
	id: GenericID;
	key: string;
	tags?: TagsObj[];
	value_length: number;
	created_at: Date;
	updated_at: Date;
}
export type SecretsCreate = Pick<SecretsInfo, "key"> & SecretsValue & Partial<Pick<SecretsInfo, "tags">>;
export type SecretsEdit = Partial<Pick<SecretsInfo, "tags"> & SecretsValue>;
export type SecretsQuery = Query<SecretsInfo, "key">;
export interface TagoCoreComputerUsage {
	total: number;
	used: number;
	description: string;
	title: string;
	type: string;
	detail: string;
}
export interface TagoCoreOS {
	name: string;
	arch: string;
	version: string;
	platform?: string;
}
export interface TagoCoreSummary {
	device: number;
	action: number;
	analysis: number;
}
export interface TagoCoreInfo {
	active: boolean;
	computer_usage: TagoCoreComputerUsage[];
	connected: boolean;
	created_at: string;
	id: GenericID;
	internet_ip: string;
	last_connection: string;
	local_ips: string;
	name: string;
	os: TagoCoreOS;
	profile: string;
	summary: TagoCoreSummary;
	system_start_time: string;
	tags: TagsObj[];
	tcore_start_time: string;
	tcore_version: string;
	token: GenericToken$1;
	updated_at: string;
	machine_id: string;
}
export interface TagoCoreListInfo {
	active: boolean;
	connected: boolean;
	created_at: string;
	id: GenericID;
	internet_ip: string;
	last_connection: string;
	local_ips: string;
	name: string;
	profile: string;
	system_start_time: string;
	tags: TagsObj[];
	tcore_start_time: string;
	tcore_version: string;
	updated_at: string;
	machine_id: string;
}
export type TagoCoreQuery = Query<TagoCoreInfo, "name" | "active" | "created_at" | "updated_at" | "last_connection" | "local_ips" | "internet_ip" | "system_start_time" | "tcore_start_time" | "machine_id">;
export interface TemplateObjDashboard {
	dashboard: GenericID;
	name: string;
	image_logo?: string;
	image_main?: string;
	/** Dashboard Setup Object */
	setup?: any;
}
export interface TemplateObjAnalysis {
	analysis: GenericID;
	name: string;
	image_logo?: string;
	image_main?: string;
	/** Analysis Setup Object */
	setup?: any;
}
export interface TemplateInstallDashboard {
	device?: {
		id: GenericID;
		bucket: GenericID;
	} | undefined;
	devices?: {
		id: GenericID;
		bucket: GenericID;
	} | undefined;
	analysis?: GenericID[] | undefined;
	replace?: {
		[field: string]: any;
	} | undefined;
}
export interface TemplateInstallAnalysis {
	device_token?: string;
	replace?: {
		[field: string]: any;
	} | undefined;
}
export interface TemplateObj {
	name: string;
	type: "dashboard" | "analysis";
	image_main?: string;
	image_logo?: string;
	updated_at: Date;
	created_at: Date;
}
export interface TemplateInstallReturn {
	dashboard?: string;
	analysis?: string;
}
interface UserOptions$1 {
	decimal_separator?: string;
	thousand_separator?: string;
	date_format?: string;
	time_format?: string;
	show_last_updated_at?: string;
}
export interface RunUserCreateInfo {
	name: string;
	email: string;
	password: string;
	timezone: string;
	company?: string;
	phone?: string | null;
	language?: string;
	active: boolean;
	newsletter?: boolean;
	options?: UserOptions$1;
}
export interface RunUserCreate {
	user: GenericID;
}
export interface RunUserInfo extends RunUserCreateInfo {
	id: GenericID;
	created_at: Date;
	otp?: {
		authenticator: boolean;
		sms: boolean;
		email: boolean;
	};
}
export interface RunUserLoginResponse {
	token: GenericToken$1;
	expire_date: ExpireTimeOption;
}
export interface RunUserCredentials {
	email: string;
	password: string;
}
export interface RunUserLogin extends RunUserCredentials {
	otp_type?: OTPType;
	pin_code?: string;
}
export interface RunNotificationInfo {
	id: GenericID;
	run_user: GenericID;
	title: string;
	message: string;
	buttons: [
	];
	read: boolean;
	created_at: Date;
	updated_at: Date;
	buttons_enabled: boolean;
	buttons_autodisable: boolean;
}
export interface AttachmentOptions {
	/** Archive itself */
	archive: string;
	/** Type of attached data e.g. “base64” */
	type?: string;
	/** Name for the archive */
	filename: string;
}
export interface TemplateOptions {
	/**
	 * Template name
	 *
	 * You can create an e-mail template on TagoRUN options at
	 * https://admin.tago.io/run
	 */
	name: string;
	/**
	 * Parameters to parse on Template
	 *
	 * You can use that parameter as local variable
	 * using $PARAMETER_KEY$
	 *
	 * example: params = { name: 'John' }
	 * will be $name$ on template document
	 */
	params?: {
		[key: string]: string | number;
	};
}
export interface EmailBase {
	/**
	 * Recipient email address(es)
	 * @example
	 * "client@example.com"
	 * ["client1@example.com", "client2@example.com"]
	 */
	to: string | string[];
	/**
	 * Sender name (optional)
	 * If not provided, the default sender name configured in TagoRUN will be used
	 * @example "My Application"
	 */
	from?: string;
	/**
	 * Subject of the e-mail
	 *
	 * only allow with message or html
	 */
	subject: string;
	/**
	 * File attachment for the email (optional)
	 * @see AttachmentOptions
	 */
	attachment?: AttachmentOptions;
}
export interface EmailRawText {
	/** Message in raw text for email body */
	message: string;
}
export interface EmailHTML {
	/** HTML email body */
	html: string;
}
export interface EmailWithTemplate {
	/**
	 * Recipient email address(es)
	 * @example
	 * "client@example.com"
	 * ["client1@example.com", "client2@example.com"]
	 */
	to: string | string[];
	/**
	 * Sender name (optional)
	 * If not provided, the default sender name configured in TagoRUN will be used
	 * @example "My Application"
	 */
	from?: string;
	/**
	 * File attachment for the email (optional)
	 * @see AttachmentOptions
	 */
	attachment?: AttachmentOptions;
	/**
	 * TagoRUN Email Template configuration
	 *
	 * Use this to send emails based on pre-defined templates in TagoRUN
	 *
	 * @see TemplateOptions
	 * @remarks When using a template with an attachment, a $URL$ variable is automatically
	 *       generated and can be used in the template to reference the attachment
	 */
	template?: TemplateOptions;
}
export type EmailWithHTML = EmailBase & EmailHTML;
export type EmailWithRawText = EmailBase & EmailRawText;
declare class Email extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send email
	 * @param email E-mail Object
	 *
	 * @example
	 * ```json
	 * { to: "client(at)company.com", subject: "Reports", message: "Hello client, it's your report" }
	 * { to: ["client(at)company.com", "client2(at)company.com"], subject: "Reports", message: "Hello client, it's your report" }
	 * { to: "client(at)company.com", subject: "Reports", html: "<p>Hello client, it's your report</p>" }
	 * { to: "client(at)company.com", template: { name: "my_template" } }
	 * ```
	 */
	send(email: EmailWithRawText): Promise<string>;
	send(email: EmailWithHTML): Promise<string>;
	send(email: EmailWithTemplate): Promise<string>;
}
export interface PDFResult {
	status: boolean;
	result: string;
}
export interface PDFParams {
	/** HTML as string */
	html?: string;
	/** HTML on base64 format */
	base64?: string;
	/**
	 * File name of pdf
	 * Without filename, it will generate base64 response
	 * With filename it will generate pdf binary
	 */
	fileName?: string;
	/** Generate pdf from URL */
	url?: string;
	/** PDF Custom Options */
	options?: {
		/** Display header and footer. Defaults to `false`. */
		displayHeaderFooter?: boolean;
		/** HTML template for the print footer. Should use the same format as the `headerTemplate`. */
		footerTemplate?: string;
		/** Paper format. If set, takes priority over `width` or `height` options. Defaults to 'Letter'. */
		format?: string;
		/**
		 * HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values
		 * into them:
		 * - `'date'` formatted print date
		 * - `'title'` document title
		 * - `'url'` document location
		 * - `'pageNumber'` current page number
		 * - `'totalPages'` total pages in the document
		 */
		headerTemplate?: string;
		/** Paper height, accepts values labeled with units. */
		height?: string | number;
		/** Paper orientation. Defaults to `false`. */
		landscape?: boolean;
		/** Paper margins, defaults to none. */
		margin?: {
			/** Top margin, accepts values labeled with units. Defaults to `0`. */
			top?: string | number;
			/** Right margin, accepts values labeled with units. Defaults to `0`. */
			right?: string | number;
			/** Bottom margin, accepts values labeled with units. Defaults to `0`. */
			bottom?: string | number;
			/** Left margin, accepts values labeled with units. Defaults to `0`. */
			left?: string | number;
		};
		/** Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages. */
		pageRanges?: string;
		/**
		 * Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format`
		 * options. Defaults to `false`, which will scale the content to fit the paper size.
		 */
		preferCSSPageSize?: boolean;
		/** Print background graphics. Defaults to `false`. */
		printBackground?: boolean;
		/** Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2. */
		scale?: number;
		/** Paper width, accepts values labeled with units. */
		width?: string | number;
	};
}
declare class PDFService extends TagoIOModule<GenericModuleParams> {
	/**
	 * Generate a PDF from html, url or base64
	 *
	 */
	generate(params: PDFParams): Promise<PDFResult>;
}
/**
 * Device class for IoT device operations
 *
 * This class provides comprehensive functionality for managing IoT devices, including
 * sending and retrieving data, streaming real-time data, and managing device configurations.
 * Each device instance requires a valid device token for authentication.
 *
 * @example Basic usage
 * ```ts
 * import { Device } from "@tago-io/sdk";
 *
 * const device = new Device({ token: "your-device-token" });
 *
 * // Send data to device
 * await device.sendData({
 *   variable: "temperature",
 *   value: 25.6,
 *   unit: "°C",
 *   time: new Date()
 * });
 *
 * // Get data from device
 * const data = await device.getData({
 *   variables: ["temperature"],
 *   qty: 10
 * });
 * ```
 *
 * @example Data streaming
 * ```ts
 * // Stream real-time data
 * for await (const chunk of device.getDataStreaming({ variables: ["sensor1"] })) {
 *   console.log("New data:", chunk);
 * }
 * ```
 */
export declare class Device extends TagoIOModule<DeviceConstructorParams> {
	/**
	 * Get information about the current device
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.info();
	 * ```
	 */
	info(): Promise<DeviceItem>;
	/**
	 * Send data to device
	 * @param data An array or one object with data to be send to TagoIO using device token
	 * @return amount of data added
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.sendData({
	 *   variable: "temperature",
	 *   unit: "F",
	 *   value: 55,
	 *   time: "2015-11-03 13:44:33",
	 *   location: { lat: 42.2974279, lng: -85.628292 },
	 * });
	 * ```
	 */
	sendData(data: DataCreate | DataCreate[]): Promise<string>;
	/**
	 * Get data from TagoIO Device.
	 * @param queryParams Object with query params
	 * @returns An array of TagoIO registers
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.getData({
	 *   query: "last_item",
	 *   variable: "humidity",
	 * });
	 * ```
	 */
	getData(queryParams?: DataQuerySummary): Promise<DataQueryNumberResponse[]>;
	getData(queryParams?: DataQueryAggregate): Promise<DataQueryNumberResponse[]>;
	getData(queryParams?: DataQueryDefault): Promise<Data[]>;
	getData(queryParams?: DataQueryFirstLast): Promise<Data[]>;
	/**
	 * Edit data in a Mutable-type device.
	 *
	 * @param data Array or object with the data to be edited, each object with the data's ID.
	 *
	 * @example
	 * ```ts
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.editData({
	 *   id: "id_of_the_data_item",
	 *   value: 123,
	 *   time: "2022-04-01 12:34:56",
	 *   location: { lat: 42.2974279, lng: -85.628292 },
	 * });
	 * ```
	 *
	 * @returns Success message with the amount of data items updated.
	 */
	editData(data: DataEdit | DataEdit[]): Promise<string>;
	/**
	 * Delete data from device
	 * @param queryParams
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.deleteData({
	 *   query: "last_item",
	 *   variable: "humidity",
	 *   value: 10
	 * });
	 * ```
	 */
	deleteData(queryParams?: DataQuery): Promise<string>;
	/**
	 * Get paronlyUnReameters from device
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.getParameters();
	 * ```
	 */
	getParameters(status: "all" | "onlyUnRead" | "onlyRead"): Promise<Required<ConfigurationParams>[]>;
	/**
	 * Mark parameter as read
	 * @param parameterID Parameter identification
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.setParameterAsRead("parameter_id");
	 * ```
	 *
	 */
	setParameterAsRead(parameterID: GenericID): Promise<string>;
	/**
	 * Get Data Streaming
	 *
	 * @experimental
	 * @param params Data Query
	 * @param options Stream options
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * for await (const items of myDevice.getDataStreaming()) {
	 *  console.log(items);
	 * }
	 * ```
	 */
	getDataStreaming(params?: DataQueryStreaming, options?: OptionsStreaming): AsyncGenerator<Data[], void, unknown>;
	/**
	 * Stream data to device
	 *
	 * @experimental
	 * @param data An array or one object with data to be send to TagoIO using device token
	 * @param options Stream options
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const data = [
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 55,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 42.2974279, lng: -85.628292 },
	 *     },
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 53,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 43.2974279, lng: -86.628292 },
	 *     },
	 *     // ...
	 *   ];
	 *
	 *   const result = await myDevice.sendDataStreaming(data, {
	 *     poolingRecordQty: 1000,
	 *     poolingTime: 1000,
	 *   });
	 * ```
	 */
	sendDataStreaming(data: DataCreate[], options: Omit<OptionsStreaming, "neverStop">): Promise<string>;
}
declare class Access extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all access rules from the application with pagination support.
	 * Use this to retrieve and manage access policies for your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/183-access-management} Access Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Access Management** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.accessManagement.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(result); // [ { id: 'access-id-123', name: '[Analysis] - Test', ...} ]
	 * ```
	 */
	list(queryObj?: AccessQuery): Promise<AccessInfo[]>;
	/**
	 * Creates a new access policy in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/183-access-management} Access Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Access Management** / **Create** in Access Management.
	 * ```typescript
	 * const newAccess = await Resources.accessManagement.create({
	 *   active: true,
	 *   name: "My Access Policy",
	 *   permissions: [
	 *     {
	 *       effect: "allow",
	 *       action: ["access"],
	 *       resource: ["access_management"],
	 *     },
	 *   ],
	 *   targets: [["analysis", "id", "analysis-id-123"]],
	 *   tags: [{ key: "type", value: "admin" }],
	 * });
	 * console.log(newAccess.am_id); // access-id-123
	 * ```
	 */
	create(accessObj: AccessCreateInfo): Promise<{
		am_id: GenericID;
	}>;
	/**
	 * Modifies an existing access policy.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/183-access-management} Access Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Access Management** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.accessManagement.edit("access-id-123", {
	 *   name: "Updated Access Policy",
	 *   permissions: [
	 *     {
	 *       effect: "allow",
	 *       action: ["edit"],
	 *       resource: ["access_management"],
	 *     },
	 *   ],
	 *   tags: [{ key: "type", value: "user" }]
	 * });
	 * console.log(result); // Access Management Successfully Updated
	 * ```
	 */
	edit(accessID: GenericID, accessObj: Partial<AccessInfo>): Promise<string>;
	/**
	 * Removes an access policy from your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/183-access-management} Access Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Access Management** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.accessManagement.delete("access-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(accessID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific access policy.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/183-access-management} Access Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Access Management** / **Access** in Access Management.
	 * ```typescript
	 * const accessInfo = await Resources.accessManagement.info("access-id-123");
	 * console.log(accessInfo); // { id: 'access-id-123', name: '[Analysis] - Test', ...}
	 * ```
	 */
	info(accessID: GenericID): Promise<AccessInfo>;
}
declare class Account extends TagoIOModule<GenericModuleParams> {
	/**
	 * Gets all account information.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Account** / **Access Account Information** in Access Management.
	 * ```typescript
	 * const accountInfo = await Resources.account.info();
	 * console.log(accountInfo); // { active: true, blocked: false, created_at: 2023-02-21T15:17:35.759Z, ... }
	 * ```
	 */
	info(): Promise<AccountInfo>;
	/**
	 * Edit account.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.edit({ name: "New Name" });
	 * console.log(result); // Account Successfully Updated
	 * ```
	 */
	edit(accountObj: Partial<AccountInfo>): Promise<string>;
	/**
	 * Delete account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/210-deleting-your-account} Deleting Your Account
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.delete();
	 * console.log(result);
	 * ```typescript
	 */
	delete(): Promise<string>;
	/**
	 * Generates and retrieves a new token for the account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/495-account-token} Account Token
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const token = await account.tokenCreate({ name: "New Token" });
	 * console.log(token);
	 * ```typescript
	 */
	static tokenCreate(tokenParams: TokenCreateInfo, region?: Regions | RegionsObj): Promise<{
		token: GenericToken$1;
	}>;
	/**
	 * Retrieve list of profiles for login and do Login.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const loginResponse = await account.login({ email: "user@example.com", password: "password" });
	 * console.log(loginResponse);
	 * ```
	 */
	static login(credentials: LoginCredentials, region?: Regions | RegionsObj): Promise<LoginResponse>;
	/**
	 * Send password recover email.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/209-resetting-my-password} Resetting My Password
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.passwordRecover("user@example.com");
	 * console.log(result);
	 * ```
	 */
	static passwordRecover(email: string, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Change account password.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/209-resetting-my-password} Resetting My Password
	 * TODO: not working
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.passwordChange("newPassword");
	 * console.log(result);
	 * ```
	 */
	passwordChange(password: string): Promise<string>;
	/**
	 * Create new TagoIO account.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.create({ name: "New Account", email: "user@example.com", password: "password" });
	 * console.log(result);
	 * ```
	 */
	static create(createParams: AccountCreateInfo, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Re-send confirmation account email.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.resendConfirmation("user@example.com");
	 * console.log(result);
	 * ```
	 */
	static resendConfirmation(email: string, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Confirm account creation.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.confirmAccount("confirmationToken");
	 * console.log(result);
	 * ```
	 */
	static confirmAccount(token: GenericToken$1, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Request the PIN Code for a given OTP Type.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.requestLoginPINCode({ email: "user@example.com", password: "password" }, "sms");
	 * console.log(result);
	 * ```
	 */
	static requestLoginPINCode(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type.
	 * You will be requested to confirm the operation with a pin code.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/526-two-factor-authentication} Two-factor Authentication (2FA)
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = account.enableOTP({ email: "user@example.com", password: "password" }, "sms");
	 * console.log(result);
	 * ```typescript
	 */
	enableOTP(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType): Promise<string>;
	/**
	 * Disable OTP for a given OTP Type.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/526-two-factor-authentication} Two-factor Authentication (2FA)
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.disableOTP({ email: "user@example.com", password: "password" }, "sms");
	 * console.log(result);
	 * ```
	 */
	disableOTP(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType): Promise<string>;
	/**
	 * Confirm OTP enabling process for a given OTP Type.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/526-two-factor-authentication} Two-factor Authentication (2FA)
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.confirmOTP("123456", "sms");
	 * console.log(result);
	 * ```
	 */
	confirmOTP(pinCode: string, typeOTP: OTPType): Promise<string>;
	/**
	 * Accept a team member invitation to become a profile's team member.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/106-sharing-your-profile} for Team Management - Sharing your profile
	 *
	 * @example
	 * ```typescript
	 * account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.acceptTeamInvitation("invitationToken");
	 * console.log(result);
	 * ```
	 */
	static acceptTeamInvitation(token: string, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Decline a team member invitation to become a profile's team member.
	 *
	 * @example
	 * ```typescript
	 * const account = new Account({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await account.declineTeamInvitation("invitationToken");
	 * console.log(result);
	 * ```
	 */
	static declineTeamInvitation(token: string, region?: Regions | RegionsObj): Promise<string>;
}
declare class Actions extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all actions from the application with pagination support.
	 * Use this to retrieve and manage actions in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/actions} Actions
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Action** / **Access** in Access Management.
	 * ```typescript
	 * const list = await Resources.actions.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(list); // [ { id: '66ab7c62e5f0db000998ce42', name: 'Action Test', ...} ]
	 * ```
	 */
	list(queryObj?: ActionQuery): Promise<ActionInfo[]>;
	/**
	 * Creates a new action in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/actions} Actions
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Action** / **Create** in Access Management.
	 * ```typescript
	 * const newAction = await Resources.actions.create({
	 *   name: "My Action",
	 *   type: "condition",
	 *   action: {
	 *     script: ["analysis-id"],
	 *     type: "script"
	 *   },
	 *   tags: [{ key: "type", value: "notification" }]
	 * });
	 * console.log(newAction.action); // action-id-123
	 * ```
	 */
	create(actionObj: ActionCreateInfo): Promise<{
		action: string;
	}>;
	/**
	 * Modifies an existing action.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/actions} Actions
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Action** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.actions.edit("action-id-123", {
	 *   name: "Updated Action",
	 *   active: false
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(actionID: GenericID, actionObj: Partial<ActionCreateInfo>): Promise<string>;
	/**
	 * Deletes an action from your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/actions} Actions
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Action** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.actions.delete("action-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(actionID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific action.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/actions} Actions
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Action** / **Access** in Access Management.
	 * ```typescript
	 * const actionInfo = await Resources.actions.info("action-id-123");
	 * console.log(actionInfo); // { id: 'action-id-123', name: 'My Action', ... }
	 * ```
	 */
	info(actionID: GenericID): Promise<ActionInfo>;
}
declare class Analyses extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all analyses from the application with pagination support.
	 * Use this to retrieve and manage analyses in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Access** in Access Management.
	 * ```typescript
	 * const list = await Resources.analysis.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(list); // [ { id: 'analysis-id-123', name: 'Analysis Test', ...} ]
	 * ```
	 */
	list<T extends AnalysisQuery>(queryObj?: T): Promise<AnalysisListItem<T["fields"] extends AnalysisQuery["fields"] ? T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : "id" | "name" : "id" | "name">[]>;
	/**
	 * Creates a new analysis in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/120-creating-analysis} Creating Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Create** in Access Management.
	 * ```typescript
	 * const newAnalysis = await Resources.analysis.create({
	 *   name: "My Analysis",
	 *   type: "node",
	 *   tags: [{ key: "type", value: "data-processing" }]
	 * });
	 * console.log(newAnalysis.id, newAnalysis.token); // analysis-id-123, analysis-token-123
	 * ```
	 */
	create(analysisObj: AnalysisCreateInfo): Promise<{
		id: GenericID;
		token: GenericToken$1;
	}>;
	/**
	 * Modifies an existing analysis.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.analysis.edit("analysis-id-123", {
	 *   name: "Updated Analysis",
	 *   active: false
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(analysisID: GenericID, analysisObj: Partial<AnalysisInfo>): Promise<string>;
	/**
	 * Deletes an analysis from your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.analysis.delete("analysis-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(analysisID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific analysis.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Access** in Access Management.
	 * ```typescript
	 * const analysisInfo = await Resources.analysis.info("analysis-id-123");
	 * console.log(analysisInfo);
	 * ```
	 */
	info(analysisID: GenericID): Promise<AnalysisInfo>;
	/**
	 * Executes an analysis with optional scope parameters.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Run Analysis** in Access Management.
	 * ```typescript
	 * const result = await Resources.analysis.run("analysis-id-123", { environment: "production" });
	 * console.log(result.analysis_token);
	 * ```
	 */
	run(analysisID: GenericID, scopeObj?: Record<string, any>): Promise<{
		analysis_token: GenericToken$1;
	}>;
	/**
	 * Generates a new token for the analysis.
	 * @remarks **This is only allowed when the analysis is running in external mode.**
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const token = await resources.analysis.tokenGenerate("analysis-id-123");
	 * console.log(token.analysis_token); // analysis-token-123
	 * ```
	 */
	tokenGenerate(analysisID: GenericID): Promise<{
		analysis_token: string;
	}>;
	/**
	 * Uploads a script file to an analysis.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Upload Analysis Script** in Access Management.
	 * ```typescript
	 * const result = await Resources.analysis.uploadScript("analysis-id-123", {
	 *   name: "script.js",
	 *   content: "base64-encoded-content",
	 *   language: "node"
	 * });
	 * console.log(result);
	 * ```
	 */
	uploadScript(analysisID: GenericID, fileObj: ScriptFile): Promise<string>;
	/**
	 * Gets a download URL for the analysis script.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/tagoio/analysis} Analysis
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Analysis** / **Download Analysis Script** in Access Management.
	 * ```typescript
	 * const download = await Resources.analysis.downloadScript("analysis-id-123", { version: 1 });
	 * console.log(download.url);
	 * ```
	 */
	downloadScript(analysisID: GenericID, options?: {
		version?: number;
	}): Promise<{
		url: string;
		size_unit: string;
		size: number;
		expire_at: Date;
	}>;
	/**
	 * Get all available snippets for a specific runtime environment.
	 * Fetches analysis code snippets from the public TagoIO snippets repository.
	 *
	 * @param runtime - The runtime environment to get snippets for
	 * @returns Promise resolving to the snippets metadata
	 *
	 * @example
	 * ```typescript
	 * const denoSnippets = await Resources.analysis.listSnippets("deno-rt2025");
	 *
	 * // Print all snippet titles
	 * denoSnippets.snippets.forEach(snippet => {
	 *   console.log(`${snippet.title}: ${snippet.description}`);
	 * });
	 * ```
	 */
	listSnippets(runtime: SnippetRuntime): Promise<SnippetsListResponse>;
	/**
	 * Get the raw source code content of a specific snippet file.
	 * Fetches the actual code content from the TagoIO snippets repository.
	 *
	 * @param runtime - The runtime environment the snippet belongs to
	 * @param filename - The filename of the snippet to retrieve
	 * @returns Promise resolving to the raw file content as string
	 *
	 * @example
	 * ```typescript
	 * // Get TypeScript code for console example
	 * const code = await Resources.analysis.getSnippetFile("deno-rt2025", "console.ts");
	 * console.log(code);
	 *
	 * // Get Python code for data processing
	 * const pythonCode = await Resources.analysis.getSnippetFile("python-rt2025", "avg-min-max.py");
	 * console.log(pythonCode);
	 * ```
	 */
	getSnippetFile(runtime: SnippetRuntime, filename: string): Promise<string>;
}
declare class Billing extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get the account subscription information.
	 */
	getSubscription(): Promise<BillingSubscription>;
	/**
	 * Edit an account's subscription to change plan, services or add-ons.
	 *
	 * Only one of either `plan`, `services`, or `addons` can be in `subscription`.
	 *
	 * @param subscription Object with updates to subscription.
	 *
	 * @throws If the subscription has a pending operation.
	 * @throws If updating more than one of plan, services and add-ons at the same time.
	 * @throws If purchasing add-ons or changing service limits on the Free plan.
	 * @throws If using an invalid coupon.
	 */
	editSubscription(subscription: BillingEditSubscription): Promise<void>;
	/**
	 * Get information for the account subscription schedule for downgrades.
	 *
	 * In the response, `subscription` reflects how the entire subscription will look
	 * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade
	 * for either plan, services or add-ons, everything is returned and not only the changes.
	 */
	getSubscriptionSchedule(): Promise<BillingSchedule>;
	/**
	 * Get pricing for plans, services and add-ons.
	 */
	getPrices(): Promise<BillingPrices>;
	/**
	 * Get pricing for plans, services and add-ons with proration when applicable.
	 */
	getProratedPrices(): Promise<BillingPrices>;
	/**
	 * Get information about the account's payment method credit card, credit balance,
	 * and the applied coupon.
	 */
	getPaymentMethod(): Promise<BillingPaymentMethod>;
	/**
	 * Edit an account's payment method.
	 *
	 * @param stripeCardToken Token for the new payment method added via Stripe API.
	 *
	 * @throws If token is invalid or Stripe can't create the payment method with it.
	 *
	 * @returns Success or error message.
	 */
	editPaymentMethod(stripeCardToken: string): Promise<string>;
	/**
	 * Remove an account's payment method from the Stripe subscription.
	 *
	 * Only removes the card if the account is on the Free plan or if it has enough credit balance.
	 *
	 * @throws If subscription is active with an upcoming invoice.
	 * @throws If account doesn't have a payment method.
	 *
	 * @returns Success or error message.
	 */
	removePaymentMethod(): Promise<string>;
	/**
	 * Get an account's billing information.
	 */
	getBillingInformation(): Promise<BillingInformation>;
	/**
	 * Edit an account's billing information.
	 *
	 * @param billingInformation Data to be updated in the account's billing information.
	 */
	editBillingInformation(billingInformation: BillingEditInformation): Promise<string>;
	/**
	 * Get the resource allocation for all profiles in an account.
	 */
	getAllocation(): Promise<BillingResourceAllocation>;
	/**
	 * Edit the resource allocation for the profiles in an account.
	 *
	 * The resource allocation array doesn't need to have an object for each of the account's profiles,
	 * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.
	 *
	 * The resource allocation object for a profile doesn't need to have all the services.
	 *
	 * @param allocation Array with the resource allocation
	 *
	 * @throws If passed an object that is not an allocation array.
	 * @throws If the account only has one profile.
	 * @throws If one of the profile IDs in the allocation array doesn't exist in the account.
	 * @throws If the allocated amount for one of the services exceeds the available amount.
	 *
	 * @returns Success message.
	 */
	editAllocation(allocation: BillingEditResourceAllocation): Promise<string>;
	/**
	 * Get the payment history for an account.
	 *
	 * The route uses pagination and the `lastId` parameter should be the `stripe_id`
	 * parameter from the last history entry.
	 *
	 * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.
	 *
	 * @throws If `lastId` is passed and is invalid.
	 *
	 * @returns Array with payment history entries or an empty array when no entries are available.
	 */
	getPaymentHistory(queryObj?: {
		amount?: number;
		lastId?: string;
	}): Promise<BillingPaymentHistoryEntry[]>;
	/**
	 * Get a summary for important information in an account's subscription.
	 *
	 * The values returned by this route are cached.
	 *
	 * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.
	 */
	getSubscriptionSummary(): Promise<BillingSubscriptionSummary | undefined>;
	/**
	 * Check if a coupon is valid by its promo code.
	 *
	 * @param code Customer-facing code for the coupon (promo code).
	 *
	 * @throws If the coupon code is not valid or not found.
	 * @throws If coupon is specific to a an account.
	 * @throws If coupon can only be applied to new subscriptions.
	 */
	checkDiscountCoupon(code?: string): Promise<BillingCoupon>;
	/**
	 * Cancel a scheduled downgrade.
	 *
	 * @throws If the subscription has no schedule.
	 *
	 * @returns Success message.
	 */
	cancelDowngrade(): Promise<string>;
	/**
	 * Retry payment for an operation where the payment was unsuccessful.
	 *
	 * Works for payment errors in recurring payments or in subscription upgrade operations.
	 *
	 * @throws If account has no subscription.
	 * @throws If there's no pending payment.
	 * @throws If payment method is declined or for other payment processing errors.
	 *
	 * @returns Success message.
	 */
	retryLastPayment(): Promise<string>;
	/**
	 * Cancel the last pending operation if the payment has failed.
	 *
	 * Works for subscription upgrade operations and not for recurring payment errors.
	 *
	 * @throws If there's no pending payment.
	 *
	 * @returns Success message.
	 */
	cancelLastOperation(): Promise<string>;
}
declare class Devices extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all devices from your application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices} Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * const list = await Resources.devices.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(list); // [ { id: '123', name: 'Device #1' ...}, { id: '456', name: 'Device #2' ...} ]
	 * ```
	 */
	list<T extends DeviceQuery>(queryObj?: T): Promise<DeviceListItem<T["fields"] extends DeviceQuery["fields"] ? T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : "id" | "name" : "id" | "name">[]>;
	/**
	 * Gets a streaming list of devices from the application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices} Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * for await (const items of await Resources.devices.listStreaming({ name: "*sensor*" })) {
	 *   console.log(items);
	 * }
	 * ```
	 */
	listStreaming(queryObj?: Omit<DeviceQuery, "page" | "amount">, options?: OptionsStreaming): AsyncGenerator<DeviceListItem[], void, unknown>;
	/**
	 * Creates a new device in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices#Adding_devices} Adding Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Create** in Access Management.
	 * ```typescript
	 * const TAGOIO_DATABASE_CONNECTOR = "62333bd36977fc001a2990c8";
	 * const TAGOIO_STORAGE_NETWORK = "62336c32ab6e0d0012e06c04";
	 * const newDevice = await Resources.devices.create({
	 *   name: "My Device",
	 *   connector: TAGOIO_DATABASE_CONNECTOR,
	 *   network: TAGOIO_STORAGE_NETWORK,
	 *   type: "mutable"
	 * });
	 * console.log(newDevice); // { device: 'device-id-123', token: 'token-123' }
	 * ```
	 */
	create(deviceObj: DeviceCreateInfo): Promise<DeviceCreateResponse>;
	/**
	 * Modifies properties of an existing device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices#Managing_and_customizing_your_device} Managing and Customizing Your Device
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.edit("device-id-123", {
	 *   name: "Updated Device Name",
	 *   active: true
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(deviceID: GenericID, deviceObj: DeviceEditInfo): Promise<string>;
	/**
	 * Deletes a device from your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices} Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.delete("device-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(deviceID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/3-devices} Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * const deviceInfo = await Resources.devices.info("device-id-123");
	 * console.log(deviceInfo); // { active: true, bucket: { id: 'device-id-123', name: 'My Device' } ... }
	 * ```
	 */
	info(deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Creates or updates device parameters.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/configuration-parameters-for-devices} Configuration Parameters for Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.paramSet("device-id-123", {
	 *   key: "config-key",
	 *   value: "config-value",
	 *   sent: false
	 * });
	 * console.log(result); // Params Successfully Updated
	 * ```
	 */
	paramSet(deviceID: GenericID, configObj: Partial<ConfigurationParams> | Partial<ConfigurationParams>[], paramID?: GenericID): Promise<string>;
	/**
	 * Lists all parameters for a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/configuration-parameters-for-devices} Configuration Parameters for Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * const params = await Resources.devices.paramList("device-id-123");
	 * console.log(params); // [ { id: 'params-id-123', key: 'config-key', value: 'config-value', sent: false } ]
	 * ```
	 */
	paramList(deviceID: GenericID, sentStatus?: boolean): Promise<Required<ConfigurationParams>[]>;
	/**
	 * Removes a parameter from a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/configuration-parameters-for-devices} Configuration Parameters for Devices
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.paramRemove("device-id-123", "param-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	paramRemove(deviceID: GenericID, paramID: GenericID): Promise<string>;
	/**
	 * Lists all tokens for a device with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/4-device-token} Device Token
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Token access** in Access Management.
	 * ```typescript
	 * const tokens = await Resources.devices.tokenList("device-id-123", {
	 *   page: 1,
	 *   fields: ["name", "token"],
	 *   amount: 10
	 * });
	 * console.log(tokens); // [ { name: 'Default', token: 'token-id-123', expire_time: 'never' } ]
	 * ```
	 */
	tokenList<T extends ListDeviceTokenQuery>(deviceID: GenericID, queryObj?: T): Promise<DeviceTokenDataList<T["fields"] extends ListDeviceTokenQuery["fields"] ? T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : "token" | "name" | "permission" : "token" | "name" | "permission">[]>;
	/**
	 * Creates a new token for a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/4-device-token} Device Token
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Token access** in Access Management.
	 * ```typescript
	 * const token = await Resources.devices.tokenCreate("device-id-123", {
	 *   name: "My Token",
	 *   permission: "full"
	 * });
	 * console.log(token); // { token: 'token-id-123', permission: 'full' }
	 * ```
	 */
	tokenCreate(deviceID: GenericID, tokenParams: TokenData): Promise<TokenCreateResponse$1>;
	/**
	 * Deletes a device token.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/4-device-token} Device Token
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Token access** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.tokenDelete("token-123");
	 * console.log(result); // Token Successfully Removed
	 * ```
	 */
	tokenDelete(token: GenericToken$1): Promise<string>;
	/**
	 * Gets the amount of data stored in a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data#Amount_of_data_records} Amount of data records
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * const amount = await Resources.devices.amount("device-id-123");
	 * console.log(amount);
	 * ```
	 */
	amount(deviceID: GenericID): Promise<number>;
	/**
	 * Retrieves data from all variables in the device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data} Device data management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Get data** in Access Management.
	 * ```typescript
	 * const data = await Resources.devices.getDeviceData("device-id-123", {
	 *   qty: 10,
	 *   variables: ["temperature"]
	 * });
	 * console.log(data); // [ { id: 'data-id-123', value: 55, variable: 'temperature' ... } ]
	 * ```
	 */
	getDeviceData(deviceId: GenericID, queryParams?: DataQuery): Promise<Data[]>;
	/**
	 * Retrieves data from device using streaming approach.
	 *
	 * @experimental
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data} Device data management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Get data** in Access Management.
	 * ```typescript
	 * for await (const data of await Resources.devices.getDeviceDataStreaming("device-id-123")) {
	 *   console.log(data);
	 * }
	 * ```
	 */
	getDeviceDataStreaming(deviceId: GenericID, params?: DataQueryStreaming, options?: OptionsStreaming): AsyncGenerator<Data[], void, unknown>;
	/**
	 * Removes all data from a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data#Emptying_your_Device_Data} Emptying your Device Data
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Delete data** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.emptyDeviceData("device-id-123");
	 * console.log(result); // Data Successfully Removed
	 * ```
	 */
	emptyDeviceData(deviceId: GenericID): Promise<string>;
	/**
	 * Sends data to a device.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/95-device-emulator} Device Emulator
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Send data** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.sendDeviceData("device-id-123", {
	 *   variable: "temperature",
	 *   unit: "F",
	 *   value: 55,
	 *   location: { lat: 42.2974279, lng: -85.628292 }
	 * });
	 * console.log(result); // 1 Data Added
	 * ```
	 */
	sendDeviceData(deviceId: GenericID, data: DataCreate | DataCreate[]): Promise<string>;
	/**
	 * Streams data to a device in chunks.
	 *
	 * @experimental
	 * @see {@link https://help.tago.io/portal/en/kb/articles/95-device-emulator} Device Emulator
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Send data** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.sendDeviceDataStreaming("device-id-123",
	 *   [{
	 *     variable: "temperature",
	 *     value: 55,
	 *     unit: "F",
	 *   }],
	 *   { poolingRecordQty: 1000 }
	 * );
	 * console.log(result);
	 * ```
	 */
	sendDeviceDataStreaming(deviceId: GenericID, data: DataCreate[], options?: Omit<OptionsStreaming, "neverStop">): Promise<string>;
	/**
	 * Edit data records in a **mutable** device using the profile token and device ID.
	 *
	 * The `updatedData` can be a single data record or an array of records to be updated,
	 * each of the records must have the `id` of the record and the fields to be updated.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data#Editing_and_deleting_variables_individually} Editing and deleting variables individually
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Edit data** in Access Management.
	 * ```ts
	 * const result = await Resources.devices.editDeviceData("myDeviceId", {
	 *  id: "idOfTheRecord",
	 *  value: "new value",
	 *  unit: "new unit"
	 * });
	 * console.log(result); // 1 item(s) updated
	 * ```
	 */
	editDeviceData(deviceId: GenericID, updatedData: DataEdit | DataEdit[]): Promise<string>;
	/**
	 * Delete data records in a **mutable** device using the profile token and device ID.
	 *
	 * See the example to understand how to use this method properly to have full control on what to delete.
	 *
	 * ! If query parameters are empty, last 15 data for the device will be deleted.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data#Editing_and_deleting_variables_individually} Editing and deleting variables individually
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Delete data** in Access Management.
	 * ```ts
	 * const result = await Resources.devices.deleteDeviceData("device-id-123", {
	 *   ids: ["record-id-1", "record-id-2"]
	 * });
	 * console.log(result); // 1 Data Removed
	 * ```
	 */
	deleteDeviceData(deviceId: GenericID, queryParams?: DataQuery): Promise<string>;
	/**
	 * Retrieves chunk information from a immutable device.
	 *
	 * @experimental
	 * @see {@link https://help.tago.io/portal/en/kb/articles/chunk-management} Chunk Management
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Manage chunks** in Access Management.
	 * ```typescript
	 * const chunks = await Resources.devices.getChunk("device-id-123");
	 * console.log(chunks); // [ { amount: 0, id: 'chunk-id-123', from: '2025-01-09T00:00:00.000+00:00', ... } ]
	 * ```
	 */
	getChunk(deviceID: GenericID): Promise<DeviceChunkData[]>;
	/**
	 * Deletes a chunk from a immutable device.
	 *
	 * @experimental
	 * @see {@link https://help.tago.io/portal/en/kb/articles/chunk-management#Delete_chunks} Delete chunks
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Manage chunks** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.deleteChunk("device-id-123", "chunk-id-123");
	 * console.log(result); // Chunk chunk-id-123 deleted
	 * ```
	 */
	deleteChunk(deviceID: GenericID, chunkID: GenericID): Promise<string>;
	/** @deprecated Use `dataBackup` instead. */
	copyChunk(params: DeviceChunkParams): Promise<DeviceChunkCopyResponse>;
	/**
	 * Schedule to export the mutable Device's data to TagoIO Files.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/55-data-export} Data Export
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Export Data** in Access Management.
	 * ```typescript
	 * const deviceID = "your-device-id";
	 * const timestamp = Date.now()
	 * const result = await Resources.devices.dataBackup({
	 *   deviceID: "device-id-123",
	 *   file_address: `/backups/${deviceID}/${timestamp}`,
	 *   headers: true
	 * });
	 * console.log(result); // { file_address: 'backups/your-device-id/1736433519380.csv' }
	 * ```
	 */
	dataBackup(params: DeviceDataBackup, chunkID?: GenericID): Promise<DeviceDataBackupResponse>;
	/**
	 * Restores data to a device from a CSV file in TagoIO Files.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/device-data#Importing} Importing
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Import Data** in Access Management.
	 * ```typescript
	 * const result = await Resources.devices.dataRestore({
	 *   deviceID: "device-id-123",
	 *   file_address: "/backups/backup.csv"
	 * });
	 * console.log(result); // Data import added to the queue successfully!
	 * ```
	 */
	dataRestore(params: DeviceDataRestore): Promise<string>;
}
declare class Buckets extends TagoIOModule<GenericModuleParams> {
	devices: Devices;
	/**
	 * Lists all devices from your application with pagination.
	 *
	 * @deprecated Use `Resources.devices.list()` instead
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * // Use this instead of Buckets
	 * const list = await Resources.devices.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(list);
	 * ```
	 */
	list<T extends DeviceQuery>(queryObj?: T): Promise<DeviceListItem<T["fields"] extends DeviceQuery["fields"] ? T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : "id" | "name" : "id" | "name">[]>;
	/**
	 * Retrieves detailed information about a specific device.
	 *
	 * @deprecated Use `Resources.devices.info()` instead
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * // Use this instead of Buckets
	 * const deviceInfo = await Resources.devices.info("device-id-123");
	 * console.log(deviceInfo);
	 * ```
	 */
	info(deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Gets the amount of data stored for a device.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Device** / **Access** in Access Management.
	 * ```typescript
	 * // Use this instead of Buckets
	 * const amount = await Resources.devices.amount("device-id-123");
	 * console.log(amount);
	 * ```
	 */
	amount(deviceID: GenericID): Promise<number>;
}
declare class Widgets extends TagoIOModule<GenericModuleParams> {
	/**
	 * Creates a new widget for a specified dashboard with the given configuration.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Create and Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.widgets.create("dashboard-id-123", {
	 *   data : [{
	 *     origin: "origin-id-123",
	 *     query: "last_value",
	 *     variables: ["temperature"]
	 *   }],
	 *   display: {
	 *     show_units: true,
	 *     show_variables: true,
	 *     variables: [{
	 *       origin: "origin-id-123",
	 *       variable: "temperature"
	 *     }]
	 *   },
	 *   label: "Temperature",
	 *   type: "display",
	 * });
	 * console.log(result); // { widget: "widget-id-456" }
	 *
	 * // To add the widget size to the dashboard
	 * // Before running this, make sure doesn't have more widgets in the dashboard.
	 * await Resources.dashboards.edit("dashboard-id-123", {
	 *  arrangement: [{ widget_id: result.widget, width: 1, height: 2, minW: 1, minH: 2, x: 0, y: 0 }]
	 * });
	 * ```
	 */
	create(dashboardID: GenericID, widgetObj: WidgetInfo): Promise<{
		widget: GenericID;
	}>;
	/**
	 * Updates an existing widget's configuration on a dashboard.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.widgets.edit("dashboard-id-123", "widget-id-456", {
	 *   label: "Updated Temperature",
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(dashboardID: GenericID, widgetID: GenericID, data: Partial<WidgetInfo>): Promise<string>;
	/**
	 * Permanently removes a widget from a dashboard.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Delete and Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.widgets.delete("dashboard-id-123", "widget-id-456");
	 * console.log(result); // Successfully Removed
	 *
	 * // To remove sizes from all widgets from a dashboard
	 * // Before running this, make sure doesn't have more widgets in the dashboard.
	 * await Resources.dashboards.edit("dashboard-id-123", { arrangement: [] });
	 * ```
	 */
	delete(dashboardID: GenericID, widgetID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific widget.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.widgets.info("dashboard-id-123", "widget-id-456");
	 * console.log(result); // { id: "widget-id-456", data: [ { query: "last_value", ... }, ... ], ... }
	 * ```
	 */
	info(dashboardID: GenericID, widgetID: GenericID): Promise<WidgetInfo>;
	/**
	 * Retrieves data or resource list for a specific widget based on the given parameters.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dashboards.widgets.getData("dashboard-id-123", "widget-id-456", {
	 *   start_date: "2025-01-01",
	 *   end_date: "2025-12-31",
	 *   timezone: "UTC"
	 * });
	 * console.log(result); // { widget: { analysis_run: null, dashboard: '6791456f8b726c0009adccec', ... }, ...}
	 * ```
	 */
	getData(dashboardID: GenericID, widgetID: GenericID, params?: GetDataModel): Promise<object>;
	/**
	 * Sends new data values to be displayed in the widget.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dashboards.widgets.sendData("dashboard-id-123", "widget-id-456", {
	 *   origin: "origin-id-123",
	 *   variable: "temperature",
	 *   value: 25.5,
	 *   unit: "C"
	 * });
	 * console.log(result); // [ '1 Data Added' ]
	 * ```
	 */
	sendData(dashboardID: GenericID, widgetID: GenericID, data: PostDataModel | PostDataModel[], bypassBucket?: boolean): Promise<object>;
	/**
	 * Updates existing data values for a specific widget.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dashboards.widgets.editData("dashboard-id-123", "widget-id-456", {
	 *   origin: "origin-id-123",
	 *   id: "data-id-789",
	 *   value: 25.5
	 * });
	 * console.log(result); // Device Data Updated
	 * ```
	 */
	editData(dashboardID: GenericID, widgetID: GenericID, data: EditDataModel | EditDataModel[], bypassBucket?: boolean): Promise<object>;
	/**
	 * Removes multiple data items from the widget by pairs of data ID and resource ID.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dashboards.widgets.deleteMultipleData(
	 *   "dashboard-id",
	 *   "widget-id",
	 *   [
	 *     "data_1-id:device_A-id",
	 *     "data_2-id:device_A-id",
	 *     "data_3-id:device_B-id",
	 *   ]
	 * );
	 * ```
	 */
	deleteData(dashboardID: GenericID, widgetID: GenericID, idPairs: GenericIDPair[]): Promise<string>;
	/**
	 * Updates resource values associated with the widget.
	 */
	editResource(dashboardID: GenericID, widgetID: GenericID, resourceData: EditDeviceResource | EditDeviceResource[], options?: EditResourceOptions): Promise<object>;
	/**
	 * Generates a new authentication token for embedding a widget. Each call regenerates the token.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dashboards.widgets.tokenGenerate("dashboard-id-123", "widget-id-456");
	 * console.log(result); // { widget_token: "widget-token-123" }
	 * ```
	 */
	tokenGenerate(dashboardID: GenericID, widgetID: GenericID): Promise<{
		widget_token: GenericToken$1;
	}>;
}
declare class Dashboards extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all dashboards from your application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["label", "asc"]
	 * });
	 * console.log(result); // [ { id: 'dashboard-id-123', label: 'My Dashboard', ...}, ... ]
	 * ```
	 */
	list(queryObj?: DashboardQuery): Promise<DashboardInfo[]>;
	/**
	 * Creates a new dashboard in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.create({
	 *   label: "My Dashboard",
	 *   tags: [{ key: "type", value: "monitoring" }]
	 * });
	 * console.log(result); // { dashboard: 'dashboard-id-123' }
	 * ```
	 */
	create(dashboardObj: DashboardCreateInfo): Promise<{
		dashboard: GenericID;
	}>;
	/**
	 * Modifies an existing dashboard's properties.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.edit("dashboard-id-123", {
	 *   label: "Updated Dashboard",
	 *   active: false
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(dashboardID: GenericID, dashboardObj: Partial<DashboardInfo>): Promise<string>;
	/**
	 * Deletes a dashboard from the application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.delete("dashboard-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(dashboardID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific dashboard.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Access** in Access Management.
	 * ```typescript
	 * const dashboardInfo = await Resources.dashboards.info("dashboard-id-123");
	 * console.log(dashboardInfo); // { id: 'dashboard-id-123', label: 'My Dashboard', ... }
	 * ```
	 */
	info(dashboardID: GenericID): Promise<DashboardInfo>;
	/**
	 * Creates a copy of an existing dashboard.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Duplicate** in Access Management.
	 * ```typescript
	 * const result = await Resources.dashboards.duplicate("dashboard-id-123", { new_label: "Copy of My Dashboard" });
	 * console.log(result);
	 * ```
	 */
	duplicate(dashboardID: GenericID, dashboardObj?: {
		setup?: object;
		new_label?: string;
	}): Promise<{
		dashboard_id: string;
		message: string;
	}>;
	/**
	 * Generates a new public access token for the dashboard.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const publicKey = await resources.dashboards.getPublicKey("dashboard-id-123", "1day");
	 * console.log(publicKey); // { token: 'token-id-123', expire_time: '2025-01-02T00:00:00.000Z' }
	 * ```
	 */
	getPublicKey(dashboardID: GenericID, expireTime?: ExpireTimeOption): Promise<PublicKeyResponse>;
	/**
	 * Lists all devices associated with the dashboard.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Related devices** in Access Management.
	 * ```typescript
	 * const devices = await Resources.dashboards.listDevicesRelated("dashboard-id-123");
	 * console.log(devices); // [ { id: 'device-id-123' }, { id: 'device-id-xyz' }, ... ]
	 * ```
	 */
	listDevicesRelated(dashboardID: GenericID): Promise<DevicesRelated[]>;
	/**
	 * Lists all analyses associated with a dashboard.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dashboard** / **Related analysis** in Access Management.
	 * ```typescript
	 * const analyses = await Resources.dashboards.listAnalysisRelated("dashboard-id-123");
	 * console.log(analyses); // [ { id: 'analysis-id-123', name: 'Analysis #1' }, ... ]
	 * ```
	 */
	listAnalysisRelated(dashboardID: GenericID): Promise<AnalysisRelated[]>;
	/**
	 * Executes an analysis from a widget's header button.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/15-dashboard-overview} Dashboard Overview
	 */
	runWidgetHeaderButtonAnalysis(analysisID: GenericID, dashboardID: GenericID, widgetID: GenericID, scope?: object): Promise<string>;
	widgets: Widgets;
}
declare class Dictionaries extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all dictionaries from your application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/487-dictionaries} Dictionaries
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.list({
	 *   page: 1,
	 *   fields: ["id", "name", "slug"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(result); // [ { id: 'dictionary-id-123', name: 'My Dictionary', slug: 'DICT' } ]
	 * ```
	 */
	list(queryObj?: DictionaryQuery): Promise<DictionaryInfo[]>;
	/**
	 * Creates a new dictionary in your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/489-using-dictionaries-multi-language} Using Dictionaries (Multi-Language)
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.create({
	 *   name: "My Dictionary",
	 *   slug: "DICT",
	 * });
	 * console.log(result.dictionary); // dictionary-id-123
	 * ```
	 */
	create(dictionaryObj: DictionaryCreateInfo): Promise<{
		dictionary: string;
	}>;
	/**
	 * Modifies an existing dictionary's properties.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/489-using-dictionaries-multi-language} Using Dictionaries (Multi-Language)
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.edit("dictionary-id-123", {
	 *   name: "Updated Dictionary",
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(dictionaryID: GenericID, dictionaryObj: Partial<DictionaryCreateInfo>): Promise<string>;
	/**
	 * Deletes a dictionary from your application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/489-using-dictionaries-multi-language} Using Dictionaries (Multi-Language)
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.delete("dictionary-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(dictionaryID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific dictionary.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/487-dictionaries} Dictionaries
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.info("dictionary-id-123");
	 * console.log(result); // { id: 'dictionary-id-123', name: 'My Dictionary', slug: 'DICT', languages: ['en-US'], ... }
	 * ```
	 */
	info(dictionaryID: GenericID): Promise<DictionaryInfo>;
	/**
	 * Edits a language's content in a dictionary.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/489-using-dictionaries-multi-language} Using Dictionaries (Multi-Language)
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.dictionaries.languageEdit("dictionary-id-123", "en-US", {
	 *   dictionary: { HELLO: "Hello" },
	 *   active: true
	 * });
	 * console.log(result); // Dictionary language Successfully Updated
	 * ```
	 */
	languageEdit(dictionaryID: GenericID, locale: string, languageObj: LanguageEditData): Promise<string>;
	/**
	 * Removes a language from a dictionary.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/489-using-dictionaries-multi-language} Using Dictionaries (Multi-Language)
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.languageDelete("dictionary-id-123", "en-US");
	 * console.log(result);
	 * ```
	 */
	languageDelete(dictionaryID: GenericID, locale: string): Promise<string>;
	/**
	 * Retrieves language-specific content from a dictionary by ID.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/487-dictionaries} Dictionaries
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.languageInfo("dictionary-id-123", "en-US", {
	 *   fallback: true
	 * });
	 * console.log(result); // { ACCEPT: 'Accept', ACCEPTED: 'Accepted', ...}
	 * ```
	 */
	languageInfo(dictionaryID: GenericID, locale: string, queryObj?: LanguageInfoQuery): Promise<LanguageData>;
	/**
	 * Retrieves language-specific content from a dictionary by its slug.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/487-dictionaries} Dictionaries
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Dictionary** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.dictionaries.languageInfoBySlug("SLUG", "en-US", {
	 *   fallback: true
	 * });
	 * console.log(result);
	 * ```
	 */
	languageInfoBySlug(slug: string, locale: string, queryObj?: LanguageInfoQuery): Promise<LanguageData>;
}
export type BufferLike = Uint8Array & {
	constructor: any;
};
declare class Files extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all files in the application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.files.list({
	 *   path: "/my/folder",
	 *   quantity: 100
	 * });
	 * console.log(result); // { total: 200, usage: 0.05, files: [ { size: 7812, ...} ], folders: [ 'my-folder' ] }
	 * ```
	 */
	list(queryObj?: FileQuery): Promise<FileListInfo>;
	/**
	 * Uploads base64 encoded files to TagoIO storage.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Upload** in Access Management.
	 * ```typescript
	 * const result = await Resources.files.uploadBase64([{
	 *   filename: "/my-files/document.pdf",
	 *   file: "base64EncodedContent",
	 *   public: true,
	 * }]);
	 * console.log(result);
	 * ```
	 */
	uploadBase64(fileList: Base64File[]): Promise<string>;
	/**
	 * Moves or renames files in TagoIO storage.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.files.move([{
	 *   from: "/old/path/file.txt",
	 *   to: "/new/path/renamed.txt"
	 * }]);
	 * console.log(result); // Successfully Updated
  
	 * ```
	 */
	move(fileList: MoveFiles[]): Promise<string>;
	/**
	 * Copies files in TagoIO files.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.files.copy([{
	 *   from: "/source/file.txt",
	 *   to: "/destination/copy.txt"
	 * }]);
	 * console.log(result);
	 * ```
	 */
	copy(fileList: CopyFiles[]): Promise<string>;
	/**
	 * Deletes files or folders from TagoIO storage.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Upload** in Access Management.
	 * ```typescript
	 * const result = await Resources.files.delete([
	 *   "/path/to/file.txt",
	 *   "/folder/to/delete"
	 * ]);
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(files: string[]): Promise<string>;
	/**
	 * Checks if a file is public or private.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Access** in Access Management.
	 * ```typescript
	 * const permission = await Resources.files.checkPermission("/path/to/file.txt");
	 * console.log(permission.public); // true or false
	 * ```
	 */
	checkPermission(file: string): Promise<{
		public: boolean;
	}>;
	/**
	 * Changes visibility settings for multiple files.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.files.changePermission([{
	 *   file: "/path/to/file.txt",
	 *   public: true
	 * }]);
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	changePermission(filesVisibility: FilesPermission[]): Promise<string>;
	private getPathFromUrl;
	/**
	 * Gets a signed URL with temporary authentication token.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Access** in Access Management.
	 * ```typescript
	 * const signedUrl = await Resources.files.getFileURLSigned("https://api.tago.io/file/...");
	 * console.log(signedUrl);
	 * ```
	 */
	getFileURLSigned(url: string): Promise<string>;
	/**
	 * Gets the MD5 hash of a file with authentication for private files.
	 * This hash can be used to verify file integrity.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Access** in Access Management
	 * ```typescript
	 * const md5Hash = await Resources.files.getFileMD5("https://storage.tago.io/file/path/document.pdf");
	 * console.log(md5Hash); // e.g. "d41d8cd98f00b204e9800998ecf8427e"
	 * ```
	 */
	getFileMD5(url: string): Promise<string>;
	/**
	 * Build the `FormData` object to be used in multipart form uploads.
	 */
	private buildFormData;
	/**
	 * Creates a multipart upload instance
	 */
	private createMultipartUpload;
	/**
	 * Uploads a single part to TagoIO
	 */
	_uploadPart(filename: string, uploadID: string, part: number, fileBlob: Blob, options?: UploadOptions): Promise<{
		ETag: string;
		PartNumber: number;
	}>;
	/**
	 * Adds an upload to the queue.
	 * It will try to upload for 'opts.maxTriesForEachChunk' and fail
	 * if it couldn't upload after those many tries.
	 */
	_addToQueue(filename: string, uploadID: GenericID, partNumber: number, blob: Blob, options?: UploadOptions): Promise<{
		ETag: string;
		PartNumber: number;
	}>;
	/**
	 * Finishes a multipart upload instance
	 */
	_completeMultipartUpload(filename: string, uploadID: string, parts: {
		ETag: string;
		PartNumber: number;
	}[], options?: UploadOptions): Promise<{
		file: string;
	}>;
	/**
	 * Uploads a single file to TagoIO using multipart upload.
	 * The file is divided into chunks and uploaded in parallel for better performance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/127-files} Files
	 * @see {@link https://help.tago.io/portal/en/kb/articles/140-uploading-files} Uploading Files
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **File** / **Upload** in Access Management.
	 * ```typescript
	 * const file = Buffer.from("file content");
	 * const result = await Resources.files.uploadFile(file, "/uploads/myfile.txt", {
	 *   chunkSize: 5 * 1024 * 1024, // 5MB chunks
	 *   onProgress: (progress) => console.log(`Upload progress: ${progress}%`)
	 * });
	 * console.log(result.file); // https://api.tago.io/file/.../uploads/myfile.txt
	 * ```
	 */
	uploadFile(file: Blob | BufferLike, filename: string, options?: UploadOptions): Promise<{
		file: string;
	}>;
	/**
	 * Throw a error if is cancelled
	 */
	private isCanceled;
}
declare class Connectors extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all connectors from the application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/466-connector-overview} Connector Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Connector** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.integration.connectors.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(result); // [ { id: 'connector-id-123', name: 'My Connector' } ]
	 * ```
	 */
	list(queryObj?: ConnectorQuery): Promise<ConnectorInfo[]>;
	/**
	 * Retrieves detailed information about a specific connector.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/466-connector-overview} Connector Overview
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Connector** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.integration.connectors.info("connector-id-123", ["id", "name"]);
	 * console.log(result); // { id: 'connector-id-123', name: 'My Connector', profile: 'profile-id-123' }
	 * ```
	 */
	info(connectorID: GenericID, fields?: string[]): Promise<ConnectorInfo>;
	/**
	 * Creates a new connector in the application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/466-connector-overview#Creating_a_connector} Creating a connector
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.connectors.create({
	 *   name: "My Connector",
	 *   type: "custom",
	 *   networks: ["network-id-123"],
	 *   enabled: true
	 * });
	 * console.log(result.connector); // 'connector-id-123'
	 * ```
	 */
	create(connectorObj: ConnectorCreateInfo): Promise<{
		connector: GenericID;
	}>;
	/**
	 * Modifies an existing connector's properties.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/466-connector-overview} Connector Overview
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.connectors.edit("connector-id-123", { name: "Updated Connector" });
	 * console.log(result); // Connector Successfully Updated
	 * ```
	 */
	edit(connectorID: GenericID, connectorObj: Partial<ConnectorCreateInfo>): Promise<string>;
	/**
	 * Deletes a connector from the application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/466-connector-overview} Connector Overview
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.connectors.delete("connector-id-123");
	 * console.log(result); // Connector Successfully Deleted
	 * ```
	 */
	delete(connectorID: string): Promise<string>;
}
declare class Networks extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all networks from the application with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/125-network-integration} Network Integration
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Network** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.integration.networks.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 10,
	 *   orderBy: ["name", "asc"]
	 * });
	 * console.log(result); // [ { id: 'network-id-123', name: 'Network Test' } ]
	 * ```
	 */
	list(queryObj?: NetworkQuery): Promise<NetworkInfo[]>;
	/**
	 * Retrieves detailed information about a specific network.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/125-network-integration} Network Integration
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Network** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.integration.networks.info("network-id-123", ["id", "name"]);
	 * console.log(result); // { id: 'network-id-123', name: 'Network Test', profile: 'profile-id-123' }
	 * ```
	 */
	info(networkID: GenericID, fields?: string[]): Promise<NetworkInfo>;
	/**
	 * Creates a new network in the application.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/468-creating-a-network-integration} Creating a Network Integration
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.networks.create({
	 *   name: "My Network",
	 *   description: "Network description"
	 * });
	 * console.log(result.network); // 'network-id-123'
	 * ```
	 */
	create(connectorObj: NetworkCreateInfo): Promise<{
		network: GenericID;
	}>;
	/**
	 * Modifies an existing network's properties.
	 *
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.networks.edit("network-id-123", { name: "Updated Network" });
	 * console.log(result); // Network Successfully Updated
	 * ```
	 */
	edit(networkID: GenericID, connectorObj: Partial<NetworkCreateInfo>): Promise<string>;
	/**
	 * Lists all tokens for a network with pagination support.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/468-creating-a-network-integration#Tokens_and_getting_the_devices} Tokens and Getting the Devices
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.networks.tokenList("network-id-123", {
	 *   page: 1,
	 *   fields: ["name", "token"]
	 * });
	 * console.log(result); // [ { name: 'Token #1', token: 'token-value' } ]
	 * ```
	 */
	tokenList(networkID: GenericID, queryObj?: ListTokenQuery): Promise<NetworkTokenInfo[]>;
	/**
	 * Creates a new token for a network.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/468-creating-a-network-integration#Tokens_and_getting_the_devices} Tokens and Getting the Devices
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const token = await resources.integration.networks.tokenCreate("network-id-123", {
	 *   name: "My Token",
	 *   permission: "full"
	 * });
	 * console.log(token); // { token: 'token-value', name: 'My Token', network: 'network-id-123' }
	 * ```
	 */
	tokenCreate(networkID: GenericID, tokenParams: TokenData): Promise<NetworkTokenCreateResponse>;
	/**
	 * Deletes a network token.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/468-creating-a-network-integration#Tokens_and_getting_the_devices} Tokens and Getting the Devices
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.networks.tokenDelete("token-123");
	 * console.log(result); // Token Successfully Removed
	 * ```
	 */
	tokenDelete(token: GenericToken$1): Promise<string>;
	/**
	 * Deletes a network from the application.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.integration.networks.delete("network-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(networkID: string): Promise<string>;
}
declare class Integration extends TagoIOModule<GenericModuleParams> {
	connectors: Connectors;
	networks: Networks;
}
declare class Notifications extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves all notifications from the application with optional filtering.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Access notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.notifications.list({ read: false, amount: 10 });
	 * console.log(result); // [ { id: 'notification-id-123', title: 'System Update', message: 'Features', ... } ]
	 * ```
	 */
	list(queryObj?: NotificationQuery): Promise<NotificationInfo[]>;
	/**
	 * Marks one or multiple notifications as read.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Edit notification** in Access Management.
	 * ```typescript
	 * // Mark single notification
	 * await Resources.notifications.markAsRead("notification-id-123");
	 *
	 * // Mark multiple notifications
	 * await Resources.notifications.markAsRead(["id-1", "id-2"]);
	 * ```
	 */
	markAsRead(notificationIDS: GenericID[] | GenericID): Promise<string>;
	/**
	 * Marks one or multiple notifications as unread.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Edit notification** in Access Management.
	 * ```typescript
	 * // Mark single notification
	 * await Resources.notifications.markAsUnread("notification-id-123");
	 *
	 * // Mark multiple notifications
	 * await Resources.notifications.markAsUnread(["id-1", "id-2"]);
	 * ```
	 */
	markAsUnread(notificationIDS: GenericID[] | GenericID): Promise<string>;
	/**
	 * Marks all notifications in the application as read.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Edit notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.notifications.markAllAsRead();
	 * console.log(result); // All TagoIO Notification Run Successfully Updated
	 * ```
	 */
	markAllAsRead(): Promise<string>;
	/**
	 * Records when a notification button is pressed by the user.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Edit notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.notifications.notificationButton("notification-123", "button-456");
	 * console.log(result);
	 * ```
	 */
	notificationButton(notificationID: GenericID, buttonID: string): Promise<string>;
	/**
	 * Creates a new notification in the system.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Create notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.notifications.create({ title: "System Update", message: "New features available" });
	 * console.log(result.id); // notification-id-123
	 * ```
	 */
	create(notificationData: NotificationCreate): Promise<{
		id: GenericID;
	}>;
	/**
	 * Permanently deletes a notification from the system.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/11-notification} Notification
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Delete notification**  in Access Management.
	 * ```typescript
	 * const result = await Resources.notifications.remove("notification-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	remove(notificationID: GenericID): Promise<string>;
	/**
	 * Registers a mobile device for push notifications.
	 * @remarks **This is used internally for mobile applications**
	 */
	registerDevice(deviceToken: GenericToken$1, platform: "ios" | "android"): Promise<string>;
	/**
	 * Removes a mobile device from push notification service.
	 * @remarks **This is used internally for mobile applications**
	 */
	unRegisterDevice(deviceToken: GenericToken$1): Promise<string>;
}
declare class PaymentHistory extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves the payment transaction history for the current account, including all past payments and their details.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.paymentHistory.getHistory();
	 * console.log(result); // [ { strip_id: 'stripe-id-123', invoice_number: 'ABC-123', status: 'paid', ... } ]
	 * ```
	 */
	getHistory(): Promise<PaymentInfo[]>;
}
export interface PaymentMethodCreateInfo {
	name: string;
	token: GenericToken$1;
	brand?: string;
	default_card?: boolean;
}
export interface PaymentMethodInfo {
	name: string;
	brand: string;
	/** Last four digits of card */
	last4: string;
	funding: string;
	exp_month: string;
	exp_year: string;
}
export interface PaymentMethodListResponse {
	card: PaymentMethodInfo;
}
declare class PaymentMethods extends TagoIOModule<GenericModuleParams> {
	/**
	 * Creates a new payment method for the current account using the provided payment information.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/204-payment-methods} Payment Methods
	 * @see {@link https://help.tago.io/portal/en/kb/articles/205-common-billing-issues} Common Billing Issues
	 */
	create(paymentMethodData: PaymentMethodCreateInfo): Promise<PaymentMethodInfo[]>;
	/**
	 * Retrieves all payment methods associated with the current account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/204-payment-methods} Payment Methods
	 * @see {@link https://help.tago.io/portal/en/kb/articles/205-common-billing-issues} Common Billing Issues
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const paymentMethods = await resources.paymentMethods.list();
	 * console.log(paymentMethods); // { card: { name: 'My Card', brand: 'Visa', last4: '1234', ... } }
	 * ```
	 */
	list(): Promise<PaymentMethodListResponse>;
	/**
	 * Removes a payment method from the account using its ID.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/204-payment-methods} Payment Methods
	 * @see {@link https://help.tago.io/portal/en/kb/articles/205-common-billing-issues} Common Billing Issues
	 */
	delete(paymentMethodID: GenericID): Promise<string>;
}
declare class Plan extends TagoIOModule<GenericModuleParams> {
	/**
	 * Sets the active plan and configures service limits for the account, including SMS, email, data records, device requests and analysis quotas.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/207-upgrading-plans-services} Upgrading Plans & Services
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.plan.setPlanParameters({
	 *   plan: "plan_id",
	 *   sms: 100,
	 *   email: 1000,
	 *   data_records: 200000,
	 *   device_request: 250,
	 *   analysis: 1000
	 * });
	 * console.log(result);
	 * ```
	 */
	setPlanParameters(data: PlanSetInfo): Promise<string>;
	/**
	 * Retrieves information about the currently active plan and its associated services.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/114-account-plans} Account Plans
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.plan.getActivePlan();
	 * console.log(result); // { plan: 'scale' }
	 * ```
	 */
	getActivePlan(): Promise<Pick<PlanInfo, "plan">>;
	/**
	 * Retrieves the current pricing information for all available services.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/114-account-plans} Account Plans
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const prices = await resources.plan.getCurrentPrices();
	 * console.log(prices); // { analysis: [ { price: 0, amount: 3000 } ], data_records: [...], ... }
	 * ```
	 */
	getCurrentPrices(): Promise<CurrentPrices>;
}
declare class Profile extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list of all profiles associated with the current account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/198-profiles} Profiles
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Account** / **Access profile** in Access Management.
	 * ```typescript
	 * const result = await Resources.profiles.list();
	 * console.log(result); // [ { id: 'profile-id-123', name: 'Profile Test', ... } ]
	 * ```
	 */
	list(): Promise<ProfileListInfo[]>;
	/**
	 * Retrieves detailed information about a specific profile using its ID or 'current' for the active profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/198-profiles} Profiles
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Account** / **Access profile** in Access Management.
	 * ```typescript
	 * const profileInfo = await Resources.profiles.info("profile-id-123");
	 * // Or get current profile
	 * const currentProfile = await Resources.profiles.info("current");
	 * console.log(profileInfo); // { info { id: 'profile-id-123', account: 'account-id-123', ...}, ... }
	 * ```
	 */
	info(profileID: GenericID | "current"): Promise<ProfileInfo>;
	/**
	 * Retrieves a summary of the profile's usage and statistics.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/198-profiles} Profiles
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Account** / **Access profile** in Access Management.
	 * ```typescript
	 * const result = await Resources.profiles.summary("profile-id-123");
	 * console.log(result); // { amount: { device: 10, bucket: 10, dashboard: 5, ... }, ... }
	 * ```
	 */
	summary(profileID: GenericID, options?: {
		onlyAmount?: boolean;
	}): Promise<ProfileSummary>;
	/**
	 * Creates a new profile with the specified name and optional resource allocation settings.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/198-profiles#Adding_Profiles} Adding Profiles
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.create({ name: "New Profile" }, { allocate_free_resources: true });
	 * console.log(result); // { id: 'profile-id-123' }
	 * ```
	 */
	create(profileObj: {
		name: string;
	}, options?: {
		allocate_free_resources?: boolean;
	}): Promise<{
		id: GenericID;
	}>;
	/**
	 * Updates profile information with the provided data.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/198-profiles#Renaming_your_Profiles} Renaming your Profiles
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.edit("profile-id-123", { name: "Updated Profile Name" });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(profileID: GenericID, profileObj: Partial<ProfileInfo>): Promise<string>;
	/**
	 * Permanently removes a profile from the account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/526-two-factor-authentication} Two-Factor Authentication (2FA)
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * // The “pin_code” field is required when 2FA is activated
	 * const result = await resources.profiles.delete("profile-id-123", { password: "your-password", pin_code: "123456" });
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(profileID: GenericID, credentials: {
		password: string;
		pin_code?: string;
	}): Promise<string>;
	/**
	 * Retrieves usage statistics for a profile within a specified time period.
	 *
	 * Usage statistics are cumulative: if a service was not used in a time period,
	 * the statistics for that time period will not be in the object.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Account** / **Access profile statistics** in Access Management.
	 * ```typescript
	 * const result = await Resources.profiles.usageStatisticList("profile-id-123", {
	 *   start_date: "2024-09-01",
	 *   end_date: "2024-12-31",
	 *   periodicity: "day"
	 * });
	 * console.log(result); // [ { time: '2024-09-02T00:01:29.749Z', analysis: 0.07, data_records: 67254, ... }, ... ]
	 * ```
	 */
	usageStatisticList(profileID: GenericID, dateObj?: StatisticsDate): Promise<UsageStatistic[]>;
	/**
	 * Creates a new audit log query for tracking profile activities.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/audit-log} Audit Log
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.auditLog("profile-id-123", {
	 *   start_date: new Date("2024-12-01"),
	 *   end_date: new Date("2024-12-07")
	 * });
	 * console.log(result);
	 * ```
	 */
	auditLog(profileID: GenericID, filterObj?: AuditLogFilter): Promise<AuditLog>;
	/**
	 * Retrieves audit log entries using a previously created query.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/audit-log} Audit Log
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await Resources.profiles.auditLogQuery("profile-id-123", "query-id-456");
	 * console.log(result);
	 * ```
	 */
	auditLogQuery(profileID: GenericID, queryId?: string): Promise<AuditLog>;
	/**
	 * Retrieves a list of all add-ons associated with the profile.
	 *
	 * @deprecated This route is deprecated.
	 */
	addonList(profileID: GenericID): Promise<AddonInfo>;
	/**
	 * Updates the add-on configuration for a profile.
	 *
	 * @deprecated This route is deprecated.
	 */
	addonEdit(profileID: GenericID, addonObj: Partial<AddonInfo>): Promise<string>;
	/**
	 * Updates service configuration and resource limits for a profile.
	 */
	serviceEdit(profileID: GenericID, serviceObj: object): Promise<string>;
	/**
	 * Transfers the current authentication token to another profile.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.transferTokenToAnotherProfile("target-profile-123");
	 * console.log(result);
	 * ```
	 */
	transferTokenToAnotherProfile(targetProfileID: GenericID): Promise<string>;
	/**
	 * Retrieves a list of all tokens associated with a specific profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/495-account-token} Account Token
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.tokenList("profile-id-123", {
	 *   page: 1,
	 *   amount: 20,
	 *   fields: ["name", "token", "permission"]
	 * });
	 * console.log(result); // [ { name: 'Token #1', token: 'token-value', permission: 'full', ... }, ... ]
	 * ```
	 */
	tokenList(profileID: GenericID, queryObj?: ListTokenQuery): Promise<Partial<TokenDataList>[]>;
	/**
	 * Creates a new authentication token for the specified profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/495-account-token} Account Token
	 * @see {@link https://help.tago.io/portal/en/kb/articles/526-two-factor-authentication} Two-Factor Authentication (2FA)
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * // The “pin_code” / "otp_type" field is required when 2FA is activated
	 * const result = await resources.profiles.tokenCreate("profile-id-123", {
	 *   name: "API Access",
	 *   permission: "full",
	 *   email: "example@email.com",
	 *   password: "your-password"
	 *  });
	 * console.log(result); // { token: 'token-value', name: 'API Access', ... }
	 * ```
	 */
	tokenCreate(profileID: GenericID, tokenParams: TokenData & Authenticator): Promise<TokenCreateResponse$1>;
	/**
	 * Revokes and removes an authentication token from the profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/495-account-token} Account Token
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.tokenDelete("profile-id-123", "token-xyz");
	 * console.log(result); // Token Successfully Removed
	 * ```
	 */
	tokenDelete(profileId: string, token: GenericToken$1): Promise<string>;
	/**
	 * Removes an add-on from the profile at the end of the current billing cycle.
	 *
	 * @deprecated This route is deprecated.
	 */
	removeAddOn(profileId: GenericID, addon: BillingAddOn): Promise<string>;
	/**
	 * Adds a new team member to the profile using their email address.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/106-sharing-your-profile} Team Management - Sharing your Profile
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.addTeamMember("profile-id-123", "user@example.com");
	 * console.log(result); // User invited
	 * ```
	 */
	addTeamMember(id: string, email: string): Promise<string>;
	/**
	 * Retrieves a list of all team members that have access to the specified profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/106-sharing-your-profile} Team Management - Sharing your Profile
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.teamList("profile-id-123");
	 * console.log(result); // [ { id: 'account-id-123', active: false, name: 'John Doe', ... }, ... ]
	 * ```
	 */
	teamList(id: string): Promise<ProfileTeam[]>;
	/**
	 * Removes a team member from the profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/106-sharing-your-profile} Team Management - Sharing your Profile
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy in Access Management.
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.profiles.deleteTeamMember("profile-id-123", "account-id-456");
	 * console.log(result); // Account Successfully Removed
	 * ```
	 */
	deleteTeamMember(id: string, accountId: string): Promise<string>;
}
declare class Run extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves information about the current Run environment configuration.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 * @see {@link https://help.tago.io/portal/en/kb/articles/run-themes} Run Themes
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Access TagoRun settings** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.info();
	 * console.log(result); // { name: 'My Run Environment', logo: 'https://example.com/logo.png', ... }
	 * ```
	 */
	info(): Promise<RunInfo>;
	/**
	 * Updates the Run environment configuration settings.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 * @see {@link https://help.tago.io/portal/en/kb/articles/run-themes} Run Themes
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Profile** / **Edit TagoRun settings** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.edit({ name: "My Run Environment", logo: "https://example.com/logo.png" });
	 * console.log(result); // TagoIO Run Successfully Updated
	 * ```
	 */
	edit(data: RecursivePartial<RunInfo>): Promise<string>;
	/**
	 * Retrieves a paginated list of Run users with customizable fields and filtering options.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 *
	 * @example
	 *
	 * If receive an error "Authorization Denied", or return empty list check policy **Run User** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.listUsers({
	 *   page: 1,
	 *   fields: ["id", "name", "email"],
	 *   amount: 20
	 * });
	 * console.log(result); // [ { id: 'user-id-123', name: 'John Doe', email: 'example@email.com' } ]
	 * ```
	 */
	listUsers<T extends UserQuery>(query: T): Promise<UserListItem<T["fields"] extends UserQuery["fields"] ? T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : never : "id" | "name">[]>;
	/**
	 * Retrieves detailed information about a specific Run user.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.userInfo("user-id-123");
	 * console.log(result); // { id: 'user-id-123', name: 'John Doe', email: 'example@email.com', ... }
	 * ```
	 */
	userInfo(userID: GenericID): Promise<UserInfo>;
	/**
	 * Creates a new user in the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.userCreate({
	 *   name: "John Doe",
	 *   email: "john@example.com",
	 *   password: "secure123",
	 *   timezone: "America/New_York",
	 * });
	 * console.log(result); // { user: 'user-id-123' }
	 * ```
	 */
	userCreate(data: UserCreateInfo): Promise<UserCreateResponse>;
	/**
	 * Updates information for an existing Run user.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Edit** in Access Management.
	 * ```typescript
	 * const userData = ;
	 * const result = await Resources.run.userEdit("user-id-123", { name: "Updated Name" });
	 * console.log(result); // TagoIO Run User Successfully Updated
	 * ```
	 */
	userEdit(userID: GenericID, data: Partial<UserInfo>): Promise<string>;
	/**
	 * Permanently deletes a user from the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/191-tagorun} TagoRun
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.userDelete("user-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	userDelete(userID: GenericID): Promise<string>;
	/**
	 * Generates a login token to authenticate as a specific Run user.
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Login as user** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.loginAsUser("user-id-123");
	 * console.log(result.token); // "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ..."
	 * ```
	 */
	loginAsUser(userID: GenericID, options?: LoginAsUserOptions): Promise<LoginResponseRun>;
	/**
	 * Tests the email configuration by sending a test message.
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.run.emailTest({ subject: "Test Email", body: "This is a test message" });
	 * console.log(result); // E-mail sent to example@email.com
	 * ```
	 */
	emailTest(data: {
		subject: string;
		body: string;
	}): Promise<string>;
	/**
	 * Retrieves a list of notifications for a specific Run user.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/223-notifications-for-users} Notifications for Users
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Access notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.notificationList("user-id-123");
	 * console.log(result); // [ { id: 'notification-id-123', title: 'System Update', message: 'Features', ... } ]
	 * ```
	 */
	notificationList(userID: GenericID): Promise<NotificationInfo[]>;
	/**
	 * Creates a new notification for a Run user.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/223-notifications-for-users} Notifications for Users
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Create notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.notificationCreate("user-id-123", { title: "Update", message: "New feature available" });
	 * console.log(result); // { id: 'notification-id-123' }
	 * ```
	 */
	notificationCreate(userID: GenericID, data: NotificationCreate): Promise<{
		id: GenericID;
	}>;
	/**
	 * Updates an existing notification in the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/223-notifications-for-users} Notifications for Users
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Edit notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.notificationEdit("notification-id-123", { title: "Updated Title" });
	 * console.log(result); // TagoIO Notification User Successfully Updated
	 * ```
	 */
	notificationEdit(notificationID: GenericID, data: Partial<NotificationCreate>): Promise<string>;
	/**
	 * Deletes a notification from the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/223-notifications-for-users} Notifications for Users
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Run User** / **Delete notification** in Access Management.
	 * ```typescript
	 * const result = await Resources.run.notificationDelete("notification-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	notificationDelete(notificationID: GenericID): Promise<string>;
	/**
	 * Retrieves the SAML Single Sign-On configuration information for the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/492-okta-sso} Okta SSO
	 * @see {@link https://help.tago.io/portal/en/kb/articles/491-single-sign-on-sso} Single Sign-On (SSO)
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.run.ssoSAMLInfo();
	 * console.log(result); // { sp: { entity_id: 'https://example.com', ... }, ... }
	 * ```
	 */
	ssoSAMLInfo(): Promise<RunSAMLInfo>;
	/**
	 * Updates the SAML SSO configuration for the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/492-okta-sso} Okta SSO
	 * @see {@link https://help.tago.io/portal/en/kb/articles/491-single-sign-on-sso} Single Sign-On (SSO)
	 */
	ssoSAMLEdit(data: RunSAMLEditInfo): Promise<string>;
	/**
	 * Creates a custom domain configuration for the Run environment.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/custom-domain-configuration} Custom Domain Configuration
	 */
	createCustomDomain(profile_id: string, customDomainData: CustomDomainCreate): Promise<string>;
	/**
	 * Retrieves the custom domain configuration for a Run profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/custom-domain-configuration} Custom Domain Configuration
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.run.getCustomDomain("profile-id-123");
	 * console.log(result);
	 * ```
	 */
	getCustomDomain(profile_id: string): Promise<CustomDomainInfo>;
	/**
	 * Removes the custom domain configuration from a Run profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/custom-domain-configuration} Custom Domain Configuration
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.run.deleteCustomDomain("profile-id-123");
	 * console.log(result);
	 * ```
	 */
	deleteCustomDomain(profile_id: string): Promise<string>;
	/**
	 * Regenerates the custom domain configuration for a Run profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/custom-domain-configuration} Custom Domain Configuration
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.run.regenerateCustomDomain("profile-id-123");
	 * console.log(result);
	 * ```
	 */
	regenerateCustomDomain(profile_id: string): Promise<string>;
}
declare class ServiceAuthorization extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a paginated list of all service authorization tokens with filtering and sorting options.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/218-authorization} Authorization
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Service Authorization** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.serviceAuthorization.tokenList({
	 *   page: 1,
	 *   fields: ["name", "token"],
	 *   amount: 20
	 * });
	 * console.log(result); // [ { name: 'API Service Token', token: 'token-xyz-123' } ]
	 * ```
	 */
	tokenList(query?: ListTokenQuery): Promise<Partial<TokenDataList>[]>;
	/**
	 * Generates and retrieves a new service authorization token with specified permissions.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/218-authorization} Authorization
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Service Authorization** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.serviceAuthorization.tokenCreate({
	 *   name: "Service Token",
	 *   verification_code: "additional parameter"
	 * });
	 * console.log(result); // { token: 'token-xyz-123', name: 'Service Token', ... }
	 * ```
	 */
	tokenCreate(tokenParams: TokenData): Promise<TokenCreateResponse>;
	/**
	 * Permanently removes a service authorization token.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/218-authorization} Authorization
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Service Authorization** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.serviceAuthorization.tokenDelete("token-xyz-123");
	 * console.log(result); // Token Successfully Removed
	 * ```
	 */
	tokenDelete(token: GenericToken): Promise<string>;
	/**
	 * Updates a service authorization token with an optional verification code.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/218-authorization} Authorization
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Service Authorization** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.serviceAuthorization.tokenEdit("token-xyz-123", "verification-code");
	 * console.log(result); // Authorization Code Successfully Updated
	 * ```
	 */
	tokenEdit(token: GenericToken, verificationCode?: string): Promise<string>;
}
declare class TagoCores extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a paginated list of all TagoCores from the application with filtering and sorting options.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const cores = await resources.tagocores.list({
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   amount: 20
	 * });
	 * console.log(cores);
	 * ```
	 */
	list(queryObj?: TagoCoreQuery): Promise<TagoCoreListInfo[]>;
	/**
	 * Retrieves detailed information about a specific TagoCore instance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const coreInfo = await resources.tagocores.info("core-id-123", true);
	 * console.log(coreInfo);
	 * ```
	 */
	info(tagoCoreID: GenericID, summary?: boolean): Promise<TagoCoreInfo>;
	/**
	 * Updates configuration and settings for a TagoCore instance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.tagocores.edit("core-id-123", { name: "Production Core" });
	 * console.log(result);
	 * ```
	 */
	edit(tagoCoreID: GenericID, tagoCoreObj: Partial<TagoCoreInfo>): Promise<string>;
	/**
	 * Generates a new authentication token for a TagoCore instance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const token = await resources.tagocores.tokenGenerate("core-id-123");
	 * console.log(token);
	 * ```
	 */
	tokenGenerate(tagoCoreID: GenericID): Promise<string>;
	/**
	 * Permanently removes a TagoCore instance and its configurations.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.tagocores.delete("core-id-123");
	 * console.log(result);
	 * ```
	 */
	delete(tagocoreID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a device connected to a Standalone TagoCore instance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const deviceInfo = await resources.tagocores.standaloneDeviceInfo("core-id-123", "device-id-456");
	 * console.log(deviceInfo);
	 * ```
	 */
	standaloneDeviceInfo(tagoCoreID: GenericID, deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Retrieves a list of all devices connected to a Standalone TagoCore instance.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tagocore} TagoCore
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const devices = await resources.tagocores.standaloneDeviceList("core-id-123", {
	 *   page: 1,
	 *   fields: ["id", "name", "last_input"],
	 *   amount: 20
	 * });
	 * console.log(devices);
	 * ```
	 */
	standaloneDeviceList<T extends DeviceQuery>(tagoCoreID: GenericID, queryObj?: T): Promise<DeviceListItem<"id" | "name" | (T["fields"] extends readonly (keyof any)[] ? T["fields"][number] : never)>[]>;
}
export type TagTypes = "bucket" | "device" | "dashboard" | "action" | "analysis" | "tcore" | "run_users" | "secrets";
declare class Tags extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves all available tag keys for a specific resource type in the account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/tags} Tags System
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 *
	 * const deviceTags = await resources.tags.getTagKeys("device");
	 * console.log(deviceTags); // [ 'tag-key1', 'tag-key2', 'tag-key3' ]
	 *
	 * const dashboardTags = await resources.tags.getTagKeys("dashboard");
	 * console.log(dashboardTags); // [ 'tag-key1', 'tag-key2', 'tag-key3' ]
	 * ```
	 */
	getTagKeys(type: TagTypes): Promise<string[]>;
}
export type TemplateInstallParams = TemplateInstallDashboard | TemplateInstallAnalysis;
declare class Template extends TagoIOModule<GenericModuleParams> {
	/**
	 * Creates a new template from a dashboard or analysis configuration.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/518-distributing-dashboards} Distributing Dashboards
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.template.generateTemplate({
	 *   name: "My Dashboard Template",
	 *   dashboard: "dashboard-id-123"
	 * });
	 * console.log(result);
	 * ```
	 */
	generateTemplate(template: TemplateObjDashboard | TemplateObjAnalysis): Promise<string>;
	/**
	 * Installs a template into the account, creating either a dashboard or analysis from the template configuration.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/518-distributing-dashboards} Distributing Dashboards
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.template.installTemplate("template-id-123");
	 * console.log(result); // { dashboard: 'dashboard-id-123' }
	 * ```
	 */
	installTemplate(templateID: GenericID, installParams?: TemplateInstallParams): Promise<TemplateInstallReturn>;
	/**
	 * Retrieves detailed information about a specific template.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/518-distributing-dashboards} Distributing Dashboards
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const template = await resources.template.getTemplate("template-id-123");
	 * console.log(template); // { type: 'dashboard', name: 'My Dashboard Template', ... }
	 * ```
	 */
	getTemplate(templateID: GenericID): Promise<TemplateObj>;
}
/**
 * @internal
 * @deprecated Moved to Resources.account
 * * Resources.account.info(); Relies on Access Manage Permissions
 * * new Resources().account.info(); Relies on Access Manage Permissions
 * * new Resources({token: "TOKEN"}).account.info(); Relies on Analysis/Profile Token
 */
declare class AccountDeprecated extends Account {
	/**
	 * @deprecated moved to Resources.actions
	 */
	actions: Actions;
	/**
	 * @deprecated moved to Resources.analysis
	 */
	analysis: Analyses;
	/**
	 * @deprecated moved to Resources.buckets
	 */
	buckets: Buckets;
	/**
	 * @deprecated moved to Resources.files
	 */
	files: Files;
	/**
	 * @deprecated moved to Resources.dashboards
	 */
	dashboards: Dashboards;
	/**
	 * @deprecated moved to Resources.devices
	 */
	devices: Devices;
	/**
	 * @deprecated moved to Resources.dictionaries
	 */
	dictionaries: Dictionaries;
	/**
	 * @deprecated moved to Resources.billing
	 */
	billing: Billing;
	/**
	 * @deprecated moved to Resources.notifications
	 */
	notifications: Notifications;
	/**
	 * @deprecated moved to Resources.tags
	 */
	tags: Tags;
	/**
	 * @deprecated moved to Resources.paymentMethods
	 */
	paymentMethods: PaymentMethods;
	/**
	 * @deprecated moved to Resources.plan
	 */
	plan: Plan;
	/**
	 * @deprecated moved to Resources.paymentHistory
	 */
	paymentHistory: PaymentHistory;
	/**
	 * @deprecated moved to Resources.integration
	 */
	integration: Integration;
	/**
	 * @deprecated moved to Resources.template
	 */
	template: Template;
	/**
	 * @deprecated moved to Resources.accessManagement
	 */
	accessManagement: Access;
	/**
	 * @deprecated moved to Resources.run
	 */
	run: Run;
	/**
	 * @deprecated moved to Resources.serviceAuthorization
	 */
	ServiceAuthorization: ServiceAuthorization;
	/**
	 * @deprecated moved to Resources.profiles
	 */
	profiles: Profile;
	/**
	 * @deprecated moved to Resources.tagocores
	 */
	tagocores: TagoCores;
}
/**
 * User List scope to be used in your analysis
 * example:
 * - async function editUser({ scope }: RouterConstructor & { scope: UserListScope[] }) {}
 */
export interface UserListScope extends Partial<Omit<UserCreateInfo, "password" | "tags">> {
	user: string;
	/** Tag keys are formated as tags.key and parameters as param.key */
	[key: string]: string | any;
	/** old parameter key will include a json with the old values of the parameters */
	old?: {
		[key: string]: string;
	} & Partial<Omit<UserCreateInfo, "password" | "tags">>;
}
/**
 * Custom Button scope to be used in your analysis functions
 * example:
 * - async function customBtnService({ scope }: RouterConstructor & { scope: CustomBtnScope[] }) {}
 */
export interface CustomBtnScope {
	/** only when using User List */
	user?: string;
	/** only when using Device List and Dynamic Table */
	device?: string;
	/** only when using Dynamic Table */
	group?: string;
	/** only when using Dynamic Table */
	variable?: string;
	/** only when using Dynamic Table */
	value?: string;
	displayValue: string;
	property: string;
}
/**
 * Device List scope to be used in your analysis functions
 * example:
 * - async function editDevice({ scope }: RouterConstructor & { scope: DeviceListScope[] }) {}
 */
export interface DeviceListScope {
	device: string;
	name?: string;
	/** Tag keys are formated as tags.key and parameters as param.key */
	[key: string]: string | any;
	/** old parameter key will include a json with the old values of the parameters */
	old?: {
		name?: string;
		[key: string]: string | undefined;
	};
}
/**
 * Router interface to be used inside your analysis
 */
export interface RouterConstructor {
	/** scope of your analysis */
	scope: any[];
	/** environment variable parsed with Utils.envToJson(context.environment) */
	environment: {
		[key: string]: string;
	};
	/** instanced account class with new Account({ token: "Your-token" }) */
	account?: AccountDeprecated;
	/** instanced device class with new Device({ token: "Your-token" }) */
	config_dev?: Device;
	/** context of your analysis */
	context?: TagoContext;
}
export interface QRCodeFormat {
	type: string;
	schema_id: string;
	join_eui: string;
	dev_eui: string;
	profile_id: string;
	owner_token?: string;
	sn_number?: string;
	proprietary?: string;
	checksum?: string;
}
export interface UploadFileOptions {
	filename: string;
	file_base64: string;
	public?: boolean;
	/** Path where the file will be stored. Such as /reports/ */
	path?: string;
}
export type HexadecimalPayload = string;
export interface DownlinkOptions {
	payload: HexadecimalPayload;
	port: string;
	confirmed?: boolean;
}
/**
 * Request configuration interface for API requests (replaces AxiosRequestConfig)
 */
export interface RequestConfig {
	url?: string;
	method?: string;
	headers?: Record<string, string>;
	data?: any;
	params?: Record<string, any>;
	timeout?: number;
}
/**
 * Metadata interface for data enrichment and visualization
 */
export interface Metadata {
	color?: string;
	x?: string | number;
	y?: string | number;
	label?: string;
	file?: {
		url: string;
		md5: string;
		path: string;
	};
	icon?: string;
	fixed_position?: {
		[key: string]: {
			color: string;
			icon: string;
			value: string;
			x: string;
			y: string;
		};
	};
	sentValues?: {
		label: string;
		value: string | number | boolean;
	}[];
	old_value?: string | number | boolean;
	[key: string]: any;
}
/** Latitude coordinate type */
export type Latitude = number;
/** Longitude coordinate type */
export type Longitude = number;
/** GeoJSON Point location format */
export type LocationGeoJSON = {
	type: "Point";
	coordinates: [
		Longitude,
		Latitude
	];
};
/** Latitude/Longitude location format */
export type LocationLatLng = {
	lat: number;
	lng: number;
};
/** Type for the data returned from the API. */
export interface Data {
	/** Data ID. */
	id: string;
	/** ID of the device holding the data. */
	device: GenericID;
	/**
	 * ID of the device holding the data.
	 *
	 * @deprecated Deprecating this in favor of `device`.
	 */
	origin?: GenericID;
	/** Name of the variable for the data. */
	variable: string;
	/** Data value. */
	value?: string | number | boolean;
	/** Group for the data. Used for grouping different data values. */
	group?: string;
	/**
	 * Series for the data. Used for grouping different data values.
	 *
	 * @deprecated Deprecating this in favor of `group`.
	 */
	serie?: string;
	/** Unit for the data value. */
	unit?: string;
	/** Location for the data value. */
	location?: LocationGeoJSON;
	/** Metadata for the data value. */
	metadata?: Metadata;
	/** Timestamp for the data value. */
	time: Date;
	/** Timestamp for the data value. Determined by the API. */
	created_at?: Date;
}
/** Type for creating data and sending it to the API. */
export type DataCreate = Required<Pick<Data, "variable">> & Partial<Omit<Data, "id" | "device" | "origin" | "location" | "time" | "created_at"> & {
	/** Location for the data value. */
	location: LocationGeoJSON | LocationLatLng | null;
	/** Timestamp for the data value. */
	time: string | Date;
}>;
/** Type for editing data and sending it to the API. */
export type DataEdit = Required<Pick<Data, "id">> & Partial<Pick<DataCreate, "value" | "group" | "serie" | "unit" | "metadata" | "time" | "location">>;
export interface TagsObj {
	key: string;
	value: string;
}
export type RecursivePartial<T> = {
	[P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};
export interface Query<T, U> {
	/** Page of list starting from 1 */
	page?: number;
	/** Amount of items will return. */
	amount?: number;
	/** Array of field names. */
	fields?: (keyof T)[];
	/** Filter object. */
	filter?: RecursivePartial<T>;
	/** Tuple with a field and an order */
	orderBy?: [
		Extract<keyof T, U>,
		"asc" | "desc"
	];
}
/** ID used on TagoIO, string with 24 character */
export type GenericID = string;
export type GenericIDPair = `${string}:${string}`;
/** Token used on TagoIO, string with 36 characters */
type GenericToken$1 = string;
export type Base64 = string;
export type PermissionOption = "write" | "read" | "full" | "deny";
export type ExpireTimeOption = "never" | Date;
export type ExportOption = "csv" | "json" | "xml";
export type Conditionals = "<" | ">" | "=" | "!" | "><" | "*";
export type RunTypeOptions = "node" | "python";
type TokenCreateResponse$1 = {
	token: GenericToken$1;
	expire_date: ExpireTimeOption;
	permission: PermissionOption;
};
export type RefType = "dashboard";
export interface TokenDataList {
	token: GenericToken$1;
	name: string;
	type: string;
	permission: PermissionOption;
	serie_number: string | null;
	last_authorization: Date | null;
	verification_code: string | null;
	expire_time: ExpireTimeOption;
	ref_id: string;
	created_at: Date;
	created_by: string | null;
}
export interface Authenticator {
	email: string;
	password: string;
	/** The "pin_code" field is required when 2FA is activated */
	pin_code?: string;
	/** The "otp_type" field is required when 2FA is activated */
	otp_type?: OTPType;
}
export interface TokenData {
	/** A name for the token. */
	name: string;
	/**
	 * The time for when the token should expire.
	 * It will be randomly generated if not included.
	 * Accepts “never” as value.
	 */
	expire_time?: ExpireTimeOption;
	/** Token permission should be 'write', 'read' or 'full'. */
	permission: PermissionOption;
	/** [optional] The serial number of the device. */
	serie_number?: string;
	/** [optional] Verification code to validate middleware requests. */
	verification_code?: string;
	/** [optional] Middleware or type of the device that will be added. */
	middleware?: string;
}
export interface ListTokenQuery extends Query<TokenDataList, "name" | "permission" | "serie_number" | "verification_code" | "created_at"> {
}
declare function addCache(requestConfig: RequestConfig, obj: any, ttlMS?: number): void;
declare function getCache(requestConfig: RequestConfig): any;
declare function clearCache(): void;
/**
 * Analysis execution context for TagoIO
 *
 * This class provides the runtime environment for executing analysis scripts in TagoIO.
 * It manages environment variables, console outputs, and analysis execution lifecycle.
 * Analyses can run locally for development or in the TagoIO cloud platform.
 *
 * @example Basic analysis usage
 * ```ts
 * import { Analysis } from "@tago-io/sdk";
 *
 * const analysis = new Analysis(async (context, scope) => {
 *   // Get analysis environment variables
 *   const environment = await context.getEnvironment();
 *
 *   // Use console service for logging
 *   context.console.log("Analysis started");
 *
 *   // Your analysis logic here
 *   console.log("Processing data...");
 * }, { token: "your-analysis-token" });
 * ```
 *
 * @example Environment variables
 * ```ts
 * const analysis = new Analysis(async (context) => {
 *   const env = await context.getEnvironment();
 *   const apiKey = env.find(e => e.key === "API_KEY")?.value;
 * });
 * ```
 *
 * @example Manual start control
 * ```ts
 * const analysis = new Analysis(myAnalysisFunction, {
 *   token: "token",
 *   autostart: false
 * });
 *
 * // Start analysis manually
 * analysis.start();
 * ```
 */
export declare class Analysis extends TagoIOModule<AnalysisConstructorParams> {
	private analysis;
	started: boolean;
	constructor(analysis: analysisFunction, params?: AnalysisConstructorParams);
	start(): void;
	private runOnTagoIO;
	private stringifyMsg;
	/**
	 * Run Analysis
	 * @internal
	 * @param environment
	 * @param data
	 * @param analysis_id
	 * @param token
	 */
	private runLocal;
	private localRuntime;
	static use(analysis: analysisFunction, params?: AnalysisConstructorParams): Analysis;
}
/**
 * Authorization utilities for TagoIO
 *
 * This class provides functionality for managing and validating authorization
 * tokens and permissions within the TagoIO platform. Used for authorization
 * validation and token information retrieval.
 *
 * @example Basic authorization info
 * ```ts
 * import { Authorization } from "@tago-io/sdk";
 *
 * const auth = new Authorization({
 *   token: "your-auth-token",
 *   details: { id: "auth-id" }
 * });
 *
 * const info = await auth.info();
 * console.log(info.permissions);
 * ```
 */
export declare class Authorization extends TagoIOModule<AuthorizationModuleParams> {
	/**
	 * Get information about the current Authorization
	 */
	info(): Promise<AuthorizationInfo>;
}
/**
 * Multi-language support for TagoIO applications
 *
 * This class provides internationalization (i18n) functionality for TagoIO applications,
 * allowing you to manage translations and apply language-specific content dynamically.
 * Supports expression parsing, language switching, and translation management.
 *
 * @example Basic dictionary usage
 * ```ts
 * import { Dictionary } from "@tago-io/sdk";
 *
 * const dictionary = new Dictionary({
 *   token: "your-token",
 *   language: "en"
 * });
 *
 * // Apply translations to a string
 * const translated = await dictionary.applyToString(
 *   "Welcome #DICT.GREETING#!",
 *   { language: "pt" }
 * );
 * ```
 *
 * @example Expression parsing
 * ```ts
 * // Parse translation expressions
 * const expressions = dictionary.getExpressionsFromString("#DICT.HELLO# #DICT.WORLD#");
 *
 * // Resolve specific expression
 * const value = await dictionary.resolveExpression({
 *   expression: { scope: "DICT", key: "HELLO" },
 *   language: "es"
 * });
 * ```
 */
export declare class Dictionary extends TagoIOModule<IDictionaryModuleParams> {
	language: string;
	runURL?: string;
	constructor(params: IDictionaryModuleParams);
	constructor(params: IDictionaryModuleParamsAnonymous);
	/**
	 * Get the language data for a dictionary.
	 *
	 * @param dictionary ID or Slug of the dictionary
	 * @param language Language code (defaults to instance language)
	 * @returns Language data or null if not found
	 * @throws Error if parameters are missing
	 */
	getLanguagesData(dictionary: string, language?: string): Promise<LanguageData | null>;
	/**
	 * Get value from a key in a specific dictionary for a language.
	 *
	 * @param language Name of the language (locale code)
	 * @param dictionary Name of the dictionary
	 * @param key Name of the key
	 * @returns The translated value or the expression if not found
	 * @throws Error if parameters are missing
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = await dictionary.getValueFromKey("en-US", "TEST", "OK_BUTTON_LABEL");
	 * ```
	 */
	getValueFromKey(language: string, dictionary: string, key: string): Promise<string>;
	/**
	 * Safely extract a dictionary expression from a string, handling quoted parameters with hashtags.
	 * @private
	 */
	private extractExpression;
	/**
	 * Parse an expression and extract the names of the dictionary, the key, and
	 * any arguments that are passed in the expression.
	 *
	 * Returns `null` if the value passed is not parseable
	 *
	 * @param expression String expression
	 * @returns Parsed expression or null if invalid
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = dictionary.parseExpression("#TAGORUN.WELCOME_TEXT,Hello");
	 * ```
	 */
	parseExpression(expression: string): IParsedExpression | null;
	/**
	 * Resolve an expression in a language, replacing the parameters in the
	 * dictionary value with the arguments passed in the expression.
	 *
	 * @param resolveParams Object with the language and the parsed expression
	 * @returns Resolved string with parameters replaced
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = await dictionary.resolveExpression({
	 *   language: "en-US",
	 *   expression: {
	 *     dictionary: "TEST",
	 *     key: "SOME_KEY",
	 *     params: ["first parameter"],
	 *   },
	 * });
	 * ```
	 */
	resolveExpression(resolveParams: IResolveExpressionParams): Promise<string>;
	/**
	 * Get all (and only) the expressions in a string and their parameters if applicable,
	 * ignoring normal words and phrases.
	 *
	 * @param rawString String with words and/or expressions
	 * @returns Array of parsed expressions found in the string
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const expressions = await dictionary.getExpressionsFromString("Words are ignored #TEST.DICT_KEY#");
	 * ```
	 */
	getExpressionsFromString(rawString: string): Promise<IParsedExpression[]>;
	/**
	 * Apply the dictionary over a string, parsing the expressions in the string and
	 * replacing them with the values found for the respective keys inside the dictionary
	 * for a language.
	 *
	 * Always returns a string. Return the translated string if there are dictionary expressions,
	 * the raw string with no changes if there are no expressions, and an empty string if `rawString`
	 * is undefined.
	 *
	 * @param rawString String with words and/or expressions
	 * @param _options Object containing options for the dictionary
	 * @returns Translated string with all expressions replaced
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const result = await dictionary.applyToString("Words are ignored #TEST.DICT_KEY#");
	 * ```
	 */
	applyToString(rawString: string, _options?: IApplyToStringOptions): Promise<string>;
}
export declare class Migration extends TagoIOModule<any> {
	static convertImagerMarkerData(widget: any, widgetData: any): any[];
	/**
	 * Returns if the widget type is supported by migration
	 */
	static hasMigrate(widget: any): boolean;
	/**
	 * Check if a widget structure is old or not,
	 * based on his type
	 */
	static isOldStructure(widget: any): boolean;
	/**
	 * Convert widget old structure to new one
	 */
	static convertWidget(widget: any): WidgetInfo;
}
/**
 * Network connector operations
 *
 * This class provides functionality for managing network connectors in TagoIO,
 * including device management, data processing, and network-specific operations.
 * Used primarily for building custom network integrations and connectors.
 *
 * @example Basic network usage
 * ```ts
 * import { Network } from "@tago-io/sdk";
 *
 * const network = new Network({
 *   token: "your-connector-token",
 *   details: { connector_id: "connector-id" }
 * });
 *
 * const info = await network.info();
 * const devices = await network.deviceList();
 * ```
 */
export declare class Network extends TagoIOModule<ConnectorModuleParams> {
	/**
	 * Get information about the current network
	 */
	info(): Promise<INetworkInfo>;
	/**
	 * Get a valid token using token serie
	 * @param serieNumber
	 * @param authorization
	 */
	resolveToken(serieNumber: string, authorization?: string): Promise<GenericToken$1>;
	/**
	 * Publish a message to the MQTT relay
	 * @param options Options for publishing the message
	 * @param options.topic The topic to publish to
	 * @param options.message The message to publish (optional)
	 * @param options.qos Quality of Service level (optional)
	 * @param options.retain Whether to retain the message (optional)
	 * @param options.device The device to publish to
	 * @returns A promise that resolves when the message is published
	 */
	publishToRelay(options: {
		topic: string;
		message?: string;
		qos?: number;
		retain?: boolean;
		device: string;
	}): Promise<string>;
	/**
	 * Retrieves a list with all devices tokens related to
	 * network and connector. Network require_devices_access
	 * param need to be true.
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc"
	 * }
	 * @param connectorID Connector identification
	 * @param queryObj Search query params
	 */
	deviceList(connectorID: GenericID, queryObj?: NetworkDeviceListQuery): Promise<NetworkDeviceListQueryInfo[]>;
	/**
	 * Create or edit param for the Device in network
	 * @param deviceID Device ID
	 * @param configObj Configuration Data
	 * @param paramID Parameter ID
	 */
	deviceParamSet(deviceID: GenericID, configObj: Partial<ConfigurationParams>, paramID?: GenericID): Promise<string>;
}
declare class Entities extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a paginated list of all entities from the account with filtering and sorting options.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities} Entities
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.list({
	 *   page: 1,
	 *   fields: ["id", "name", "tags"],
	 *   amount: 20
	 * });
	 * console.log(result); // [ { id: 'entity-id-123', name: 'test', tags: [] }, ... ]
	 * ```
	 */
	list(queryObj?: EntityQuery, options?: {
		paramsSerializer?: any;
	}): Promise<EntityListItem[]>;
	/**
	 * Creates a new entity in the account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Creating_an_Entity} Creating an Entity
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.create({
	 *  name: "Temperature Sensors",
	 *  schema: {
	 *    temperature: { action: "create", type: "float", required: true } }
	 * });
	 * console.log(result); // { id: 'entity-id-123' }
	 * ```
	 */
	create(entityObj: EntityCreateInfo): Promise<{
		id: string;
	}>;
	/**
	 * Updates an existing entity's properties.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_fields} Managing Fields
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.edit("entity-id-123", { name: "Updated Entity Name" });
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	edit(entityID: GenericID, entityObj: Partial<EntityCreateInfo>): Promise<{
		message: string;
	}>;
	/**
	 * Permanently removes an entity from the account.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_fields} Managing Fields
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.delete("entity-id-123");
	 * console.log(result); // Entity Successfully Removed
	 * ```
	 */
	delete(entityID: GenericID): Promise<string>;
	/**
	 * Retrieves detailed information about a specific entity.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities} Entities
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.info("entity-id-123");
	 * console.log(result); // { schema: { id: { type: 'uuid', required: true }, ... }, ... }
	 * ```
	 */
	info(entityID: GenericID): Promise<EntityInfo>;
	/**
	 * Gets the total amount of data records stored in the entity.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities} Entities
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.amount("entity-id-123");
	 * console.log(result);
	 * ```
	 */
	amount(entityID: GenericID): Promise<number>;
	/**
	 * Retrieves data records stored in a specific entity with optional filtering parameters.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_the_data_in_your_Entity} Managing the data in your Entity
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.getEntityData("entity-id-123", { amount: 10, orderBy: "created_at,desc" });
	 * console.log(result); // [ { id: 'record-id-123', created_at: 2025-01-22T13:45:30.913Z, ... }, ... ]
	 *
	 * // Filtering by a specific field
	 * const result = await Resources.entities.getEntityData("entity-id-123", {
	 *   filter: { temperature: "30" },
	 *   index: "temp_idx",
	 *   amount: 9999,
	 * });
	 * console.log(result); // [ { id: 'record-id-123', created_at: 2025-01-22T13:45:30.913Z, ... }, ... ]
	 * ```
	 */
	getEntityData(entityID: GenericID, queryParams?: EntityDataQuery, options?: {
		paramsSerializer?: any;
	}): Promise<EntityData[]>;
	/**
	 * Updates existing data records in an entity.
	 *
	 * The `updatedData` can be a single data record or an array of records to be updated,
	 * each of the records must have the `id` of the record and the fields to be updated.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_the_data_in_your_Entity} Managing the data in your Entity
	 *
	 * @example
	 * ```typescript
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.entities.editEntityData("entity-id-123", {
	 *   id: "record-id-123",
	 *   temperature: 30.1
	 * });
	 * console.log(result); // 1 item(s) updated
	 * ```
	 */
	editEntityData(entityID: GenericID, updatedData: ({
		id: GenericID;
	} & Partial<EntityData>) | Array<{
		id: GenericID;
	} & Partial<EntityData>>): Promise<string>;
	/**
	 * Sends new data records to an entity.
	 *
	 * The `data` can be a single data record or an array of records to be sent.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_the_data_in_your_Entity} Managing the data in your Entity
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.sendEntityData("entity-id-123", { temperature: 25.5 });
	 * console.log(result); // 1 Data Added
	 * ```
	 */
	sendEntityData(entityID: GenericID, data: EntityUnknownData | EntityUnknownData[]): Promise<string>;
	/**
	 * Delete data records in a entity using the profile token and entity ID.
	 *
	 * See the example to understand how to use this method properly to have full control on what to delete.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_the_data_in_your_Entity} Managing the data in your Entity
	 *
	 * @example
	 * ```ts
	 * const resources = new Resources({ token: "YOUR-PROFILE-TOKEN" });
	 * const result = await resources.entities.deleteEntityData("myEntityID", { ids: ["idOfTheRecord1"] });
	 * console.log(result); // 1 item(s) deleted
	 * ```
	 *
	 */
	deleteEntityData(entityID: GenericID, itemsToDelete: {
		ids: GenericID[];
	}): Promise<string>;
	/**
	 * Modifies the entity schema by adding new fields or managing indexes.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Indexing_fields_to_improve_searching_and_sorting} Indexing fields to improve searching and sorting
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.editSchemaIndex("entity-id-123", {
	 *   schema: { unit: { action: "create", type: "float", required: false } },
	 *   index: { temp_idx: { action: "create", fields: ["temperature"] } }
	 * });
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	editSchemaIndex(entityID: GenericID, data: {
		schema?: EntitySchema;
		index?: Record<string, {
			action?: "create";
			fields?: string[];
		} | {
			action?: "delete";
		}>;
	}): Promise<{
		message: string;
	}>;
	/**
	 * Renames a field in the entity schema.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_fields} Managing Fields
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.renameField("entity-id-123", "old_name", "new_name");
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	renameField(entityID: GenericID, field: string, newName: string): Promise<{
		message: string;
	}>;
	/**
	 * Updates a field's configuration in the entity schema.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_fields} Managing Fields
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.updateField("entity-id-123", "temperature", { required: false });
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	updateField(entityID: GenericID, field: string, data: Partial<EntitySchema>): Promise<{
		message: string;
	}>;
	/**
	 * Removes a field from the entity schema.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_fields} Managing Fields
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.deleteField("entity-id-123", "old_field");
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	deleteField(entityID: GenericID, field: string): Promise<{
		message: string;
	}>;
	/**
	 * Removes an index from the entity schema.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Indexing_fields_to_improve_searching_and_sorting} Indexing fields to improve searching and sorting
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.deleteIndex("entity-id-123", "temp_idx");
	 * console.log(result); // { message: 'Entity Successfully Updated' }
	 * ```
	 */
	deleteIndex(entityID: GenericID, index: string): Promise<{
		message: string;
	}>;
	/**
	 * Removes all data records from an entity while preserving its structure and configuration.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/entities#Managing_the_data_in_your_Entity} Managing the data in your Entity
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Entity** / **Delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.entities.emptyEntityData("entity-id-123");
	 * console.log(result); // Data Successfully Removed
	 * ```
	 */
	emptyEntityData(entityId: GenericID): Promise<string>;
}
declare class Secrets extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a paginated list of all secrets stored in the profile with filtering and sorting options.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} Secrets
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Secrets** / **Access** in Access Management.
	 * ```typescript
	 * const result = await Resources.secrets.list({
	 *   page: 1,
	 *   fields: ["id", "key"],
	 *   amount: 20
	 * });
	 * console.log(result); // [ { id: 'secret-id-123', key: 'API_KEY' } ]
	 * ```
	 */
	list(queryObj?: SecretsQuery): Promise<SecretsInfo[]>;
	/**
	 * Retrieves detailed information about a specific secret using its ID.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} Secrets
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Secrets** / **Access** in Access Management.
	 * ```typescript
	 * const secretInfo = await Resources.secrets.info("secret-id-123");
	 * console.log(secretInfo); // { id: 'secret-id-123', key: 'API_KEY' }
	 * ```
	 */
	info(secretID: GenericID): Promise<SecretsInfo>;
	/**
	 * Creates a new secret in the profile with the specified key and value.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets#Creating_a_Secret} Creating a Secret
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Secrets** / **Create** in Access Management.
	 * ```typescript
	 * const result = await Resources.secrets.create({
	 *   key: "API_KEY",
	 *   value: "my-secret-value"
	 * });
	 * console.log(result); // { id: 'secret-id-132 }
	 * ```
	 */
	create(secretObj: SecretsCreate): Promise<{
		id: GenericID;
	}>;
	/**
	 * Modifies the properties of an existing secret.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} Secrets
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Secrets** / **Edit** in Access Management.
	 * ```typescript
	 * const result = await Resources.secrets.edit("secret-id-123", {
	 *   value: "new-secret-value",
	 *   tags: [{ key: "type", value: "user" }]
	 * });
	 * console.log(result); // Successfully Updated
	 * ```
	 */
	edit(secretID: GenericID, secretObj: SecretsEdit): Promise<string>;
	/**
	 * Permanently removes a secret from the profile.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} Secrets
	 *
	 * @example
	 * If receive an error "Authorization Denied", check policy **Secrets** / **delete** in Access Management.
	 * ```typescript
	 * const result = await Resources.secrets.delete("secret-id-123");
	 * console.log(result); // Successfully Removed
	 * ```
	 */
	delete(secretID: GenericID): Promise<string>;
}
/**
 * Main API resource manager for TagoIO
 *
 * This class provides access to all TagoIO API resources including devices, analyses,
 * dashboards, users, billing, and more. It serves as the central hub for managing
 * your TagoIO account and resources using your account token.
 *
 * @example Basic usage
 * ```ts
 * import { Resources } from "@tago-io/sdk";
 *
 * const resources = new Resources({ token: "your-account-token" });
 *
 * // List all devices
 * const devices = await resources.devices.list();
 *
 * // Create a new device
 * const newDevice = await resources.devices.create({
 *   name: "My Device",
 *   connector: "my-connector-id"
 * });
 * ```
 *
 * @example Static methods for quick access
 * ```ts
 * // Using static methods for one-off operations
 * const devices = await Resources.devices.list();
 * const account = await Resources.account.info();
 * ```
 *
 * @example Resource management
 * ```ts
 * const resources = new Resources({ token: "account-token" });
 *
 * // Manage dashboards
 * const dashboards = await resources.dashboards.list();
 *
 * // Manage users and access
 * const profile = await resources.profile.info();
 * const billing = await resources.billing.getUsageQuota();
 * ```
 */
export declare class Resources extends TagoIOModule<GenericModuleParams> {
	constructor(params?: GenericModuleParams);
	account: Account;
	static get account(): Account;
	actions: Actions;
	static get actions(): Actions;
	analysis: Analyses;
	static get analysis(): Analyses;
	buckets: Buckets;
	static get buckets(): Buckets;
	files: Files;
	static get files(): Files;
	dashboards: Dashboards;
	static get dashboards(): Dashboards;
	devices: Devices;
	static get devices(): Devices;
	dictionaries: Dictionaries;
	static get dictionaries(): Dictionaries;
	billing: Billing;
	static get billing(): Billing;
	notifications: Notifications;
	static get notifications(): Notifications;
	tags: Tags;
	static get tags(): Tags;
	paymentMethods: PaymentMethods;
	static get paymentMethods(): PaymentMethods;
	plan: Plan;
	static get plan(): Plan;
	paymentHistory: PaymentHistory;
	static get paymentHistory(): PaymentHistory;
	integration: Integration;
	static get integration(): Integration;
	template: Template;
	static get template(): Template;
	accessManagement: Access;
	static get accessManagement(): Access;
	run: Run;
	static get run(): Run;
	serviceAuthorization: ServiceAuthorization;
	static get serviceAuthorization(): ServiceAuthorization;
	profiles: Profile;
	static get profiles(): Profile;
	tagocores: TagoCores;
	static get tagocores(): TagoCores;
	secrets: Secrets;
	static get secrets(): Secrets;
	entities: Entities;
	static get entities(): Entities;
}
declare class SDB extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 */
	getItem(tagoRunURL: string, key: string): Promise<any>;
	/**
	 * Creates or updates a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 * @param value Value of the parameter
	 */
	setItem(tagoRunURL: string, key: string, value: string): Promise<any>;
	/**
	 * Delete a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 */
	removeItem(tagoRunURL: string, key: string): Promise<any>;
}
/**
 * End-user runtime context for TagoIO Run applications
 *
 * This class provides functionality for managing end-users in TagoIO Run applications,
 * including user authentication, profile management, and user-specific data operations.
 * Used primarily in customer-facing applications built with TagoIO Run.
 *
 * @example User authentication
 * ```ts
 * import { RunUser } from "@tago-io/sdk";
 *
 * const runUser = new RunUser({ token: "your-run-token" });
 *
 * // User login
 * const loginResult = await runUser.login({
 *   email: "user@example.com",
 *   password: "userpassword"
 * });
 *
 * // Get user info
 * const userInfo = await runUser.info();
 * ```
 *
 * @example User management
 * ```ts
 * // Create a new user
 * const newUser = await runUser.create({
 *   email: "newuser@example.com",
 *   password: "securepassword",
 *   name: "New User"
 * });
 *
 * // Access user-specific database
 * const sdb = runUser.sdb;
 * await sdb.set("user_preference", "dark_mode");
 * ```
 */
export declare class RunUser extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	info(tagoIORunURL: string): Promise<RunUserInfo>;
	/**
	 * Create new TagoIO Run User (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param newUserObj New user data
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static create(tagoIORunURL: string, newUserObj: RunUserCreateInfo, region?: Regions | RegionsObj): Promise<RunUserCreate>;
	/**
	 * Edit Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param userChangesObj Data to change in user
	 */
	edit(tagoIORunURL: string, userChangesObj: Partial<RunUserInfo>): Promise<string>;
	/**
	 * Delete Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	delete(tagoIORunURL: string): Promise<string>;
	/**
	 * Login at TagoIO Run as user (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param credentialsObj Run user credentials
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static login(tagoIORunURL: string, credentialsObj: RunUserLogin, region?: Regions | RegionsObj): Promise<RunUserLoginResponse>;
	/**
	 * Confirm User on TagoIO Run (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param token TagoIO Run user token
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static confirmUser(tagoIORunURL: string, token: GenericToken$1, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Sends a password recover e-mail
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param email Run user email to recover the password
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static passwordRecover(tagoIORunURL: string, email: string, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Change password using token of the password recover.
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param password New password
	 */
	passwordChange(tagoIORunURL: string, password: string): Promise<string>;
	/**
	 * List notifications.
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	notificationList(tagoIORunURL: string, queryObj?: NotificationQuery): Promise<NotificationInfo[]>;
	/**
	 * Mark notification as read
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationIDs array of notification ids or a single id
	 */
	notificationMarkRead(tagoIORunURL: string, notificationIDs: GenericID | GenericID[]): Promise<string>;
	/**
	 * Mark notification as unread
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationIDs array of notification ids or a single id
	 */
	notificationMarkUnread(tagoIORunURL: string, notificationIDs: GenericID | GenericID[]): Promise<string>;
	/**
	 * Mark all notifications as read
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	notificationMarkAllRead(tagoIORunURL: string): Promise<string>;
	/**
	 * Trigger notification button
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationID TagoIO Run notification id
	 * @param buttonID Notification button id
	 */
	notificationButton(tagoIORunURL: string, notificationID: GenericID, buttonID: GenericID): Promise<any>;
	/**
	 * Delete notification
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationID TagoIO Run notification id
	 */
	notificationDelete(tagoIORunURL: string, notificationID: GenericID): Promise<string>;
	/**
	 * Request the PIN Code for a given OTP Type.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	static requestLoginPINCode(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType, region?: Regions | RegionsObj): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type.
	 * You will be requested to confirm the operation with a pin code.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	enableOTP(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	disableOTP(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType): Promise<string>;
	/**
	 * Confirm OTP enabling process for a given OTP Type
	 * @param typeOTP authenticator, sms or email
	 */
	confirmOTP(tagoIORunURL: string, pinCode: string, typeOTP: OTPType): Promise<string>;
	SDB: SDB;
}
export interface ArchiveFile {
	name: string;
	content: Base64;
	type: string;
}
declare class Attachment extends TagoIOModule<GenericModuleParams> {
	/**
	 *  Send Attachment
	 * @param archive Archive JSON Object
	 */
	upload(archive: ArchiveFile): Promise<string>;
}
export interface AWSCredentials {
	/** AWS region, e.g., us-east-1 */
	aws_region: string;
	/** SQS queue URL */
	queue_url: string;
	/** AWS Access Key ID */
	access_key_id: string;
	/** AWS Secret Access Key */
	secret_access_key: string;
}
export interface AWSSQSData {
	/** SQS secret or AWS credentials */
	sqs_secret: string | AWSCredentials;
	/** Message to be sent to SQS */
	data?: Partial<Data> | Partial<Data>[];
}
declare class AWSSQS extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send a message to Amazon SQS
	 *
	 * @param sqsData - The AWS SQS object containing all necessary information
	 * @returns A promise that resolves to a success message
	 *
	 * @remarks
	 * This method requires valid AWS credentials and SQS queue information.
	 * For enhanced security, it's strongly recommended to store these credentials
	 * using TagoIO Secrets rather than hardcoding them.
	 *
	 * @see {@link https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html} for AWS SQS documentation
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} for TagoIO Secrets usage
	 *
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const sqsService = new Services({ token: context.token }).aws_sqs;
	 * const result = await sqsService.sendMessage({
	 *   sqs_secret: environment.AWS_SQS_TAGOIO_SECRET,
	 *   data: { variable: "temperature", value: 1 }
	 * });
	 * console.log(result);
	 * ```
	 */
	sendMessage(sqsData: AWSSQSData): Promise<string>;
}
declare class ConsoleService extends TagoIOModule<GenericModuleParams> {
	/**
	 * Log message in analysis console
	 * @param message Log message
	 * @param time Date of message
	 */
	log(message: string, time?: Date): Promise<string>;
}
export interface MQTTData {
	/** Topic of the message */
	topic: string;
	/** Message scope */
	message: string;
	/** Device to receive message */
	device: GenericID;
	/** Options of the publishing message */
	options?: {
		/** Default 0 */
		qos?: number;
	};
}
export interface MQTTDataDeprecated extends Omit<MQTTData, "device"> {
	/**
	 * Bucket to receive message
	 * @deprecated use "device" instead
	 */
	bucket: GenericID;
}
declare class MQTT extends TagoIOModule<GenericModuleParams> {
	/**
	 * Publish MQTT
	 * @param mqtt MQTT Object
	 */
	publish(mqtt: MQTTData | MQTTDataDeprecated): Promise<string>;
}
declare class Notification$1 extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send Notification
	 * You can add ref_id from a bucket or dashboard,
	 * if it is valid it will show up a button Go To Dashboard
	 * Any account with share of the dashboard/bucket will receive too.
	 * @param notification Notification Object
	 */
	send(notification: NotificationCreate): Promise<string>;
}
export interface SendgridCredentials {
	sendgrid_api_key: string;
}
export type SendgridEmailBase = EmailBase & SendgridCredentials;
export type SendgridEmailWithTemplate = EmailWithTemplate & SendgridCredentials;
export type SendgridEmailWithHTML = SendgridEmailBase & EmailHTML;
export type SendgridEmailWithRawText = SendgridEmailBase & EmailRawText;
declare class Sendgrid extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send email using Sendgrid integration
	 *
	 * @param email - The email object containing all necessary information
	 * @returns A promise that resolves to a success message
	 *
	 * @remarks
	 * This method requires Sendgrid API key.
	 * For enhanced security, it's strongly recommended to use TagoIO Secrets
	 * rather than hardcoding credentials.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} for TagoIO Secrets usage
	 *
	 * @example
	 * ```typescript
	 * const sendgridService = new Services({ token: context.token }).sendgrid;
	 * const result = await sendgridService.send({
	 *   from: "sender@company.com",
	 *   to: "client@company.com",
	 *   subject: "Reports",
	 *   message: "Hello client, it's your report",
	 *   sendgrid_api_key: "YOUR_SENDGRID_API_KEY"
	 * });
	 * console.log(result);
	 * ```
	 *
	 * @example
	 * // Using an array of recipients
	 * const result = await sendgridService.send({
	 *   from: "sender@company.com",
	 *   to: ["client1@company.com", "client2@company.com"],
	 *   subject: "Reports",
	 *   message: "Hello clients, it's your report",
	 *   sendgrid_api_key: "YOUR_SENDGRID_API_KEY"
	 * });
	 *
	 * @example
	 * // Sending HTML content
	 * const result = await sendgridService.send({
	 *   from: "sender@company.com",
	 *   to: "client@company.com",
	 *   subject: "Reports",
	 *   html: "<p>Hello client, it's your <strong>report</strong></p>",
	 *   sendgrid_api_key: "YOUR_SENDGRID_API_KEY"
	 * });
	 *
	 * @example
	 * // Using a template
	 * const result = await sendgridService.send({
	 *   from: "sender@company.com",
	 *   to: "client@company.com",
	 *   template: { name: "my_template" },
	 *   sendgrid_api_key: "YOUR_SENDGRID_API_KEY"
	 * });
	 *
	 * @example
	 * // Using attachment
	 * const html = "<h1>Hello World</h1>";
	 * const base64 = Buffer.from(html).toString("base64");
	 * const pdfService = new Services({ token: context.token }).pdf;
	 * const pdfBase64 = await pdfService.generate({ base64, options: {
	 *  displayHeaderFooter: true,
	 *  margin: {
	 *     top: "1.5cm",
	 *     right: "1.5cm",
	 *     left: "1.5cm",
	 *     bottom: "1.5cm",
	 *   },
	 * }});
	 *
	 * const sendgridService = new Services({ token: context.token }).sendgrid;
	 * await sendgridService.send({
	 *  from: "sender@company.com",
	 *  to: "client@company.com",
	 *  subject: "Reports",
	 *  message: "Hello clients, it's your report",
	 *  attachment: {
	 *    archive: pdfBase64.result,
	 *    type: "base64",
	 *    filename: "report.pdf",
	 *  },
	 *  sendgrid_api_key: "YOUR_SENDGRID_API_KEY"
	 * });
	 */
	send(email: SendgridEmailWithRawText): Promise<string>;
	send(email: SendgridEmailWithHTML): Promise<string>;
	send(email: SendgridEmailWithTemplate): Promise<string>;
}
export interface SMSData {
	/** Number to send SMS, Example: +5599999999999 */
	to: string;
	/** Message to be send */
	message: string;
}
declare class SMS extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send SMS to phone number
	 * @param sms SMS Object
	 */
	send(sms: SMSData): Promise<string>;
}
export type SMTPCredentials = {
	smtp_secret: string | {
		smtp_server: string;
		smtp_port: number;
		username: string;
		password: string;
	};
};
export type SMTPEmailBase = EmailBase & SMTPCredentials;
export type SMTPEmailWithTemplate = EmailWithTemplate & SMTPCredentials;
export type SMTPEmailWithHTML = SMTPEmailBase & EmailHTML;
export type SMTPEmailWithRawText = SMTPEmailBase & EmailRawText;
declare class SMTP extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send email using SMTP Integration
	 *
	 * @param email - The email object containing all necessary information
	 * @returns A promise that resolves to a success message
	 *
	 * @remarks
	 * This method requires either a TagoIO SMTP Secret or SMTP credentials.
	 * For enhanced security, it's strongly recommended to use TagoIO Secrets
	 * rather than hardcoding credentials.
	 *
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} for TagoIO Secrets usage
	 *
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const emailService = new Services({ token: context.token }).smtp;
	 * const result = await emailService.send({
	 *   to: "client@company.com",
	 *   subject: "Reports",
	 *   message: "Hello client, it's your report",
	 *   smtp_secret: environment.SMTP_TAGOIO_SECRET
	 * });
	 * console.log(result);
	 * ```
	 *
	 * @example
	 * // Using an array of recipients
	 * const result = await emailService.send({
	 *   to: ["client1@company.com", "client2@company.com"],
	 *   subject: "Reports",
	 *   message: "Hello clients, it's your report",
	 *   smtp_secret: environment.SMTP_TAGOIO_SECRET
	 * });
	 *
	 * @example
	 * // Sending HTML content
	 * const result = await emailService.send({
	 *   to: "client@company.com",
	 *   subject: "Reports",
	 *   html: "<p>Hello client, it's your <strong>report</strong></p>",
	 *   smtp_secret: environment.SMTP_TAGOIO_SECRET
	 * });
	 *
	 * @example
	 * // Using a template
	 * const result = await emailService.send({
	 *   to: "client@company.com",
	 *   template: { name: "my_template" },
	 *   smtp_secret: environment.SMTP_TAGOIO_SECRET
	 * });
	 */
	send(email: SMTPEmailWithRawText): Promise<string>;
	send(email: SMTPEmailWithHTML): Promise<string>;
	send(email: SMTPEmailWithTemplate): Promise<string>;
}
export interface TwilioWhatsappData {
	/** Number to send Whatsapp message, Example: +5599999999999 */
	to: string;
	/** From number registered with Twilio, Example: +5599999999999 */
	from: string;
	/** Twilio account SID */
	twilio_sid: string;
	/** Twilio auth token */
	twilio_token: string;
}
export interface TwilioWhatsappDataMessage extends TwilioWhatsappData {
	/** Message to be send */
	message: string;
}
export interface TwilioWhatsappDataAttachment extends TwilioWhatsappDataMessage {
	/** Content/Type of the request when sending a file, must be the same content type of the file */
	content_type: string;
	/**
	 * File attachment for the whatsapp (optional)
	 * @see AttachmentOptions
	 */
	attachment: AttachmentOptions;
}
export interface TwilioWhatsappDataTemplate extends TwilioWhatsappData {
	/** Template SID for the message */
	content_sid: string;
	/** Template Variables for the message */
	content_variables: {
		[key: string]: string;
	};
}
declare class TwilioWhatsapp extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send Whatsapp message to a phone number using Twilio Integration
	 *
	 * @param whatsapp - The Whatsapp object containing all necessary information
	 * @returns A promise that resolves to a success message
	 *
	 * @remarks
	 * This method requires a Twilio account with valid credentials (SID and Token).
	 * For enhanced security, it's strongly recommended to store these credentials
	 * using TagoIO Secrets rather than hardcoding them.
	 *
	 * Supported media types:
	 * Images: JPG, JPEG, PNG, WEBP*
	 * Audio: OGG**, AMR, 3GP, AAC, MPEG
	 * Documents: PDF, DOC, DOCX, PPTX, XLSX
	 * Video: MP4 (with H.264 video codec and AAC audio)
	 * Contacts: vCard (.vcf)
	 * The maximum size limit is 16MB. Please note that the size limit for images is only 5 MB
	 *
	 * @see {@link https://www.twilio.com/console} for Twilio account management
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} for TagoIO Secrets usage
	 *
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioWhatsappService = new Services({ token: context.token }).twilio_whatsapp;
	 * const result = await twilioWhatsappService.send({
	 *   to: "+1234567890",
	 *   message: "Hello from TagoIO!",
	 *   from: "+0987654321",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 * });
	 * console.log(result);
	 * ```
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioWhatsappService = new Services({ token: context.token }).twilio_whatsapp;
	 * const result = await twilioWhatsappService.send({
	 *   to: "+1234567890",
	 *   message: "Hello from TagoIO!",
	 *   from: "+0987654321",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 *   content_type: "image/jpeg",
	 *   attachment: {
	 *    filename: "image.jpg",
	 *    archive: "base64_encoded_image",
	 *   },
	 * });
	 * console.log(result);
	 * ```
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioWhatsappService = new Services({ token: context.token }).twilio_whatsapp;
	 * const result = await twilioWhatsappService.send({
	 *   to: "+1234567890",
	 *   content_variables: {"1":"Hello","2":"World"},
	 *   from: "+0987654321",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 *   content_sid: environment.CONTENT_SID,
	 * });
	 * console.log(result);
	 * ```
	 */
	send(whatsapp: TwilioWhatsappDataMessage): Promise<string>;
	send(whatsapp: TwilioWhatsappDataTemplate): Promise<string>;
	send(whatsapp: TwilioWhatsappDataAttachment): Promise<string>;
}
export interface TwilioData {
	/** Number to send SMS, Example: +5599999999999 */
	to: string;
	/** Message to be send */
	message: string;
	/** From number registered with Twilio, Example: +5599999999999 */
	from: string;
	/** Twilio account SID */
	twilio_sid: string;
	/** Twilio auth token */
	twilio_token: string;
}
declare class Twilio extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send SMS to a phone number using Twilio Integration
	 *
	 * @param sms - The SMS object containing all necessary information
	 * @returns A promise that resolves to a success message
	 *
	 * @remarks
	 * This method requires a Twilio account with valid credentials (SID and Token).
	 * For enhanced security, it's strongly recommended to store these credentials
	 * using TagoIO Secrets rather than hardcoding them.
	 *
	 * @see {@link https://www.twilio.com/console} for Twilio account management
	 * @see {@link https://help.tago.io/portal/en/kb/articles/secrets} for TagoIO Secrets usage
	 *
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioService = new Services({ token: context.token }).twilio;
	 * const result = await twilioService.send({
	 *   to: "+1234567890",
	 *   message: "Hello from TagoIO!",
	 *   from: "+0987654321",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 * });
	 * console.log(result);
	 * ```
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioService = new Services({ token: context.token }).twilio;
	 * const result = await twilioService.send({
	 *   to: "+1234567890",
	 *   message: "Hello from TagoIO!",
	 *   from: "MYFROMID",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 * });
	 * console.log(result);
	 * ```
	 * @example
	 * ```typescript
	 * const environment = Utils.envToJson(context.environment);
	 * const twilioService = new Services({ token: context.token }).twilio;
	 * const result = await twilioService.send({
	 *   to: "+1234567890",
	 *   message: "Hello from TagoIO!",
	 *   from: "MGXXXXXXXXXXXXXXXX",
	 *   twilio_sid: environment.TWILIO_SID,
	 *   twilio_token: environment.TWILIO_TOKEN,
	 * });
	 * console.log(result);
	 * ```
	 */
	send(sms: TwilioData): Promise<string>;
}
/**
 * Service abstractions for external integrations
 *
 * This class provides convenient interfaces for integrating with external services
 * commonly used in IoT applications, including messaging, notifications, file handling,
 * and third-party platforms. All services are configured with your analysis token.
 *
 * @example SMS notifications
 * ```ts
 * import { Services } from "@tago-io/sdk";
 *
 * const services = new Services({ token: "your-analysis-token" });
 *
 * await services.sms.send({
 *   to: "+1234567890",
 *   message: "Alert: Temperature threshold exceeded!"
 * });
 * ```
 *
 * @example Email with attachments
 * ```ts
 * await services.email.send({
 *   to: "user@example.com",
 *   subject: "IoT Report",
 *   message: "Please find the report attached.",
 *   attachment: services.attachment.create(pdfBuffer, "report.pdf")
 * });
 * ```
 *
 * @example Console logging (for analysis debugging)
 * ```ts
 * services.console.log("Processing data...");
 * services.console.error("Failed to connect to sensor");
 * ```
 *
 * @example Static methods for quick access
 * ```ts
 * // Using static methods for one-off operations
 * await Services.notification.send({
 *   message: "System alert",
 *   title: "IoT Alert"
 * });
 * ```
 */
export declare class Services extends TagoIOModule<GenericModuleParams> {
	constructor(params?: GenericModuleParams);
	console: ConsoleService;
	static get console(): ConsoleService;
	sms: SMS;
	static get sms(): SMS;
	email: Email;
	static get email(): Email;
	twilio: Twilio;
	static get twilio(): Twilio;
	smtp: SMTP;
	static get smtp(): SMTP;
	aws_sqs: AWSSQS;
	static get aws_sqs(): AWSSQS;
	sendgrid: Sendgrid;
	static get sendgrid(): Sendgrid;
	twilio_whatsapp: TwilioWhatsapp;
	static get twilio_whatsapp(): TwilioWhatsapp;
	/** @internal @deprecated renamed to .mqtt (lowercase) */
	MQTT: MQTT;
	mqtt: MQTT;
	static get mqtt(): MQTT;
	/** @internal @deprecated renamed to .notification (lowercase)  */
	Notification: Notification$1;
	notification: Notification$1;
	static get notification(): Notification$1;
	/** @internal @deprecated renamed to .attachment (lowercase) */
	Attachment: Attachment;
	attachment: Attachment;
	static get attachment(): Attachment;
	/** @internal @deprecated renamed to .pdf (lowercase) */
	PDF: PDFService;
	pdf: PDFService;
	static get pdf(): PDFService;
}
declare function envToJson(environment: AnalysisEnvironment[]): {
	[key: string]: string;
};
declare class GetAPIVersion extends TagoIOModule<GenericModuleParams> {
	/**
	 * Gets the current TagoIO API version
	 * @param region Optional region to check version for
	 * @returns Promise resolving to version string
	 */
	static getVersion(region?: Regions | RegionsObj): Promise<string>;
}
declare const getVersion: typeof GetAPIVersion.getVersion;
declare function getDevice(account: AccountDeprecated, device_id: string): Promise<Device>;
declare function getTokenByName(account: AccountDeprecated, deviceID: string, names?: string[] | string): Promise<string | null>;
declare function parseQRCode(qr_code: string): QRCodeFormat;
declare class RouterService {
	private serviceFunction;
	private whenList;
	constructor(service: (...args: any[]) => any);
	private addFunc;
	/**
	 * Return true if specific variables are in the scope.
	 * Information is available if Analysis is triggered by an widget or action.
	 */
	whenVariables(variable: string | string[]): RouterService;
	/**
	 * Return true if variable is included in any variable name in the scope.
	 * Information is available if Analysis is triggered by an widget or action.
	 */
	whenVariableLike(variable: string): RouterService;
	/**
	 * Return true if value is present for any variable in the scope
	 * Information is available if Analysis is triggered by an widget or action.
	 */
	whenValues(values: string | boolean | number | (string | boolean | number)[]): RouterService;
	/**
	 * Return true if serie is present for any variable in the scope
	 * Information is available if Analysis is triggered by an widget or action.
	 */
	whenSeries(series: string | string[]): RouterService;
	/**
	 * Return true if input form ID is the same
	 * Information is available if Analysis is triggered by an input widget.
	 */
	whenInputFormID(id: string): RouterService;
	/**
	 * Return true if device list identifier ID is the same as sent by widget
	 * Information is available if Analysis is triggered by an input widget.
	 */
	whenDeviceListIdentifier(btn_id: string): RouterService;
	/**
	 * Return true if user list identifier ID is the same as sent by widget
	 * Information is available if Analysis is triggered by an input widget.
	 */
	whenUserListIdentifier(btn_id: string): RouterService;
	/**
	 * Return true if custom btn ID is the same as sent by widget.
	 * Information is available if Analysis is triggered by an input widget.
	 */
	whenCustomBtnID(btn_id: string): RouterService;
	/**
	 * Return true if a parameter key exists in the scope array
	 * Useful to be used with Device List widget.
	 */
	whenParameterExists(parameter: string): RouterService;
	/**
	 * Return true if widget_exec is the same
	 * Information is available if Analysis is triggered by an widget.
	 */
	whenWidgetExec(widget_exec: "insert" | "delete" | "edit"): RouterService;
	/**
	 * Return true if action_when is the same
	 * Information is available if Analysis is triggered by an action.
	 */
	whenActionWhen(action_when: "create" | "update" | "delete" | "mqtt_connect" | "mqtt_disconnect"): RouterService;
	/**
	 * Return true if action_type is the same
	 * Information is available if Analysis is triggered by an action.
	 */
	whenActionType(action_type: "resource" | "condition" | "delete"): RouterService;
	/**
	 * Return true if input form ID is the same
	 * Information is always available.
	 */
	whenEnv(key: string, value: string): RouterService;
	/**
	 * Start verifying if all when conditions are true.
	 */
	verifyConditionsTrue(scope: any, environment: any): boolean;
	/**
	 *
	 * @param router_params
	 * @returns
	 */
	runService(router_params: RouterConstructor): any;
	getServiceName(): string;
}
declare class AnalysisRouter {
	private params;
	services: RouterService[];
	/**
	 * Create an Analysis Router.
	 * Use router.register to register new routes for your analysis.
	 * Use router.exec() to execute the router and run your functions.
	 * Example:
	 *      router.register(myFunction).whenInputFormID('create-device-input');
	 *      router.exec();
	 */
	constructor(params: RouterConstructor);
	register(func: (parameters: RouterConstructor) => any): RouterService;
	/**
	 * Start the router. It will pick the service if all conditions are match
	 * and send all parameter provided to the final function.
	 * @returns json with status and services that run
	 */
	exec(): Promise<{
		status: boolean;
		services: string[];
	}>;
}
declare function sendDownlink(resource: AccountDeprecated | Resources, device_id: string, dn_options: DownlinkOptions): Promise<string>;
declare function updateMultipleDropdown(device: Device, variables: string | string[], values: string | string[]): Promise<void>;
export type FileURL = string;
declare function uploadFile(resource: AccountDeprecated | Resources, options: UploadFileOptions): Promise<FileURL>;

declare namespace Utils {
	export { AnalysisRouter, envToJson, getDevice, getTokenByName, getVersion as getAPIVersion, parseQRCode as parseLorawanQRCode, sendDownlink, updateMultipleDropdown, uploadFile };
}
declare namespace Cache$1 {
	export { addCache, clearCache, getCache };
}
declare namespace SSE {
	export { OpenSSEConfig, channels, openSSEListening };
}

export {
	AccountDeprecated as Account,
	Cache$1 as Cache,
	GenericToken as ServiceAuthGenericToken,
	GenericToken$1 as GenericToken,
	Permissions$1 as Permissions,
	SSE,
	TokenCreateResponse as ServiceAuthTokenCreateResponse,
	TokenCreateResponse$1 as TokenCreateResponse,
	Utils,
};

export {};
